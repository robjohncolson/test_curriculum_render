<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AP Stats Consensus Quiz</title>
    <!-- Load curriculum data -->
<script src="embeddedCurriculum.js"></script>
<script src="allUnitsData.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .unit-selector {
            text-align: center;
            padding: 20px;
        }
        .unit-selector h2 {
            color: #2c3e50;
            margin-bottom: 30px;
        }
        .unit-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .unit-btn {
            padding: 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-align: left;
        }
        .unit-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .unit-btn.loading {
            background: #95a5a6;
            cursor: wait;
        }
        .back-button {
            background: #7f8c8d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .back-button:hover {
            background: #5f6c6d;
        }
        .quiz-container {
            background: white;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        .question-header {
            background: #3498db;
            color: white;
            padding: 10px 15px;
            margin: -25px -25px 20px -25px;
            border-radius: 6px 6px 0 0;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .question-id {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
        .question-prompt {
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #2c3e50;
        }
        .table-container {
            margin: 15px 0;
            overflow-x: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
            background: #f8f9fa;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 15px;
            text-align: left;
        }
        th {
            background-color: #343a40;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .chart-container {
            margin: 20px 0;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 2px solid #e9ecef;
        }
        .chart-title {
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
            color: #495057;
        }
        .chart-canvas {
            position: relative;
            height: 400px;
            width: 100%;
        }
        .choices {
            margin-top: 15px;
        }
        .choice {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            padding: 12px 15px;
            margin: 8px 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
        }
        .choice:hover:not(.disabled) {
            background: #fff9c4;
            border-color: #ffd54f;
            cursor: pointer;
        }
        .choice.selected {
            background: #e3f2fd;
            border-color: #2196F3;
        }
        .choice.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .choice input[type="radio"] {
            margin-right: 10px;
            cursor: pointer;
        }
        .choice input[type="radio"]:disabled {
            cursor: not-allowed;
        }
        .choice label {
            cursor: pointer;
            display: flex;
            align-items: center;
            width: 100%;
        }
        .choice.disabled label {
            cursor: not-allowed;
        }
        .choice-key {
            font-weight: bold;
            display: inline-block;
            width: 30px;
            color: #495057;
        }
        .answer-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }
        .reason-wrapper {
            margin-bottom: 15px;
        }
        .reason-label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #495057;
        }
        .reason-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }
        .reason-textarea:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.2);
        }
        .reason-textarea.required {
            border-color: #ff9800;
        }
        .frq-textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }
        .frq-textarea:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.2);
        }
        .submit-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .submit-button:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-1px);
        }
        .submit-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .error-msg {
            color: #f44336;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }
        .error-msg.show {
            display: block;
        }
        .success-msg {
            color: #4CAF50;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }
        .success-msg.show {
            display: block;
        }
        .dotplot-section {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }
        .dotplot-section.show {
            display: block;
        }
        .consensus-msg {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
        }
        .consensus-msg.consensus {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .consensus-msg.no-consensus {
            background: #fff3e0;
            color: #f57c00;
        }
        .contributors-list {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        .contributor-item {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .contributor-item:last-child {
            border-bottom: none;
        }
        .contributor-choice {
            font-weight: bold;
            color: #3498db;
        }
        .contributor-reason {
            font-style: italic;
            color: #666;
            margin-top: 4px;
            font-size: 0.9em;
        }
        .app-controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .sync-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .sync-button:hover {
            background: #1976D2;
        }
        .master-sync-container {
            margin-top: 10px;
            width: 100%;
        }
        .master-sync-container .sync-button {
            background: #9C27B0;
            width: 100%;
        }
        .master-sync-container .sync-button:hover {
            background: #7B1FA2;
        }
        .sync-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .sync-modal > div {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
        }
        .sync-stats {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .sync-stats div {
            margin: 5px 0;
            font-size: 16px;
        }
        body.dark-theme .sync-modal > div {
            background: #2d2d2d;
            color: #e0e0e0;
        }
        body.dark-theme .sync-stats {
            background: #1e1e1e;
        }
        .lesson-selector {
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 8px;
            text-align: center;
        }
        .lesson-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }
        .lesson-btn {
            padding: 10px 20px;
            background: white;
            color: #2196F3;
            border: 2px solid #2196F3;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .lesson-btn:hover {
            background: #2196F3;
            color: white;
        }
        .lesson-btn.active {
            background: #2196F3;
            color: white;
        }
        .lesson-btn.completed {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        .loading-msg {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }
        .username-welcome {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            color: #1976d2;
        }
        .username-prompt {
            background: #fff3e0;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        .username-input {
            padding: 10px 15px;
            border: 2px solid #ff9800;
            border-radius: 4px;
            font-size: 16px;
            margin: 0 10px;
            width: 250px;
        }
        .start-button {
            background: #ff9800;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin-left: 10px;
        }
        .start-button:hover {
            background: #f57c00;
        }
        .message {
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            animation: slideIn 0.3s ease;
        }
        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .message.error {
            background: #f8d7da;
            border: 2px solid #dc3545;
            color: #721c24;
        }
        .message.success {
            background: #d4edda;
            border: 2px solid #28a745;
            color: #155724;
        }
        /* Dark mode */
        body.dark-theme {
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        body.dark-theme .container {
            background: #2d2d2d;
            color: #e0e0e0;
        }
        body.dark-theme .quiz-container {
            background: #2d2d2d;
            border-color: #5BC0EB;
            color: #e0e0e0;
        }
        body.dark-theme .question-header {
            background: #5BC0EB;
            color: #1a1a1a;
        }
        body.dark-theme .choice {
            background: #333333;
            border-color: #555555;
            color: #e0e0e0;
        }
        body.dark-theme .choice:hover:not(.disabled) {
            background: #665c00;
            border-color: #ffcc00;
        }
        body.dark-theme .choice.selected {
            background: #1e3a5f;
            border-color: #5BC0EB;
        }
        /* Theme toggle */
        .theme-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            z-index: 1001;
        }
        .theme-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        body.dark-theme .theme-toggle {
            background: #2d2d2d;
            color: #ffd700;
            border-color: #ffd700;
        }

        .consensus-msg {
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: bold;
            text-align: center;
            font-size: 16px;
        }

        .consensus-msg.consensus {
            background: #e8f5e9;
            color: #2e7d32;
            border: 2px solid #4CAF50;
        }

        .consensus-msg.no-consensus {
            background: #fff3e0;
            color: #f57c00;
            border: 2px solid #ff9800;
        }

/* Vote button styles */
.vote-btn {
    padding: 5px 10px;
    margin: 0 5px;
    border: 1px solid #ddd;
    background: white;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 12px;
}
.vote-btn:hover {
    background: #f8f9fa;
    border-color: #bbb;
}
.vote-btn.active {
    background: #e3f2fd;
    border-color: #2196F3;
    color: #1976D2;
}

/* Pig Sprite Styles */
.pig-sprite {
    position: fixed;
    width: 32px;
    height: 32px;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA5gAAADECAYAAAD6bI6sAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAADmKADAAQAAAABAAAAxAAAAAD+OvF/AAAYa0lEQVR4Ae3d0XHcuLIA0PEtR6NctEHIIeyGsQ7BDsLORen4vVt1y1XTY7EHZIMEwbNfC4FsNA5aI6FIWJ9+vL39unX876/v3z91DJ+G3nt+e4+XAhRfMPv8irmGCzf7+s0+v+EKqjih2ddv9vkVl8Nw4WZfv9nnN1xBFSc0+/rtPb+9xysuhzRc7/n9J83ABQQIECBAgAABAgQIECBA4AkBG8wnkFxCgAABAgQIECBAgAABArmADWZu5AoCBAgQIECAAAECBAgQeELgc7zm9eUlfqmp/fP9ven6vS/ee357jzebZ+93xK92RjjWh/qMIvft7PNMfd57tbay7z/1uSyqPo/9NyTUp/pcEjj654P6XFqd2y37/Ix384wi9+3o6QnmvY8WAQIECBAgQIAAAQIECKwUsMFcCec2AgQIECBAgAABAgQIELgXsMG899AiQIAAAQIECBAgQIAAgZUCD2cwV8b58Lbe76B/OPCkHVf39A78cmHHd+CXr67vVZ/OsC9Vlfpc0unf5/Nz2Vh9Lvv07lWfy8Lqc9nnbL2z/77kCebZKlK+BAgQIECAAAECBAgQGFTABnPQhZEWAQIECBAgQIAAAQIEziZgg3m2FZMvAQIECBAgQIAAAQIEBhUoP4O59R36QZ0OS4tnX/rZ34Hvq3e7qc++wupzm6/63OaX3a0+M6HlfvW57LO1V31uE1Sf2/zi3Vfz9AQzVoA2AQIECBAgQIAAAQIECKwSsMFcxeYmAgQIECBAgAABAgQIEIgCNphRRJsAAQIECBAgQIAAAQIEVgmUn8FclYWbCOwkcLV34HdiNUyRgPosghSmi4D67MIqaJGA+iyCFIZAgYAnmAWIQhAgQIAAAQIECBAgQIDA7WaDqQoIECBAgAABAgQIECBAoETABrOEURACBAgQIECAAAECBAgQsMFUAwQIECBAgAABAgQIECBQImCDWcIoCAECBAgQIECAAAECBAjYYKoBAgQIECBAgAABAgQIECgRsMEsYRSEAAECBAgQIECAAAECBGww1QABAgQIECBAgAABAgQIlAjYYJYwCkKAAAECBAgQIECAAAECNphqgAABAgQIECBAgAABAgRKBGwwSxgFIUCAAAECBAgQIECAAAEbTDVAgAABAgQIECBAgAABAiUCNpgljIIQIECAAAECBAgQIECAgA2mGiBAgAABAgQIECBAgACBEgEbzBJGQQgQIECAAAECBAgQIEDABlMNECBAgAABAgQIECBAgECJgA1mCaMgBAgQIECAAAECBAgQIGCDqQYIECBAgAABAgQIECBAoETABrOEURACBAgQIECAAAECBAgQ+FxN8OmffzaF/PXvv5vuz27emt+Pt7dsiE39Mb/okfVvGvwPN2fjZf1/COlLEwnE9W+dWqzv1vuz67fm1/v7Pctf/zaBreuvPrf5u3tZQH0u++g9VkB9Hut/9tE9wTz7CsqfAAECBAgQIECAAAECgwjYYA6yENIgQIAAAQIECBAgQIDA2QVsMM++gvInQIAAAQIECBAgQIDAIALlZzAHmddp04hnfuI78LG/90TjeEfns3W+Mf/WeNGj9f7s+q35OTOYCY/dv3X91efY63v27NTn2Vdw7vzV59zra3bnEvAE81zrJVsCBAgQIECAAAECBAgMK2CDOezSSIwAAQIECBAgQIAAAQLnErDBPNd6yZYAAQIECBAgQIAAAQLDCjiDOdjSxDME8UxV1l89nWy8rL86H/EIECBAgAABAgQInEkg/r7cmnvcD7Ten12/Nb/4b4B4gpmJ6ydAgAABAgQIECBAgACBpwRsMJ9ichEBAgQIECBAgAABAgQIZAI2mJmQfgIECBAgQIAAAQIECBB4SsAZzKeY9rsoe8c666/ONBsv66/ORzwCBAgQIECAAAECBMYV8ARz3LWRGQECBAgQIECAAAECBE4lYIN5quWSLAECBAgQIECAAAECBMYVsMEcd21kRoAAAQIECBAgQIAAgVMJlJ/BHP1M3tb8fr6/n2qBJUugp8DW76eeuf039tb8fL/3XqG+8beuf9/s1Gdv39Hjq8/RV+ja+anP2vW/mqcnmLX1IxoBAgQIECBAgAABAgQuK2CDedmlN3ECBAgQIECAAAECBAjUCthg1nqKRoAAAQIECBAgQIAAgcsKlJ/BvKykiZ9C4GrvwJ9iUST5W0B9/qbwPwMKqM8BF0VKvwXU528K/0PgcAFPMA9fAgkQIECAAAECBAgQIEBgDgEbzDnW0SwIECBAgAABAgQIECBwuIAN5uFLIAECBAgQIECAAAECBAjMIfBwBrP33317fXnZVa73fLLJ9B7/ap6Zt/42gbPXZ+/82zRdXS3Qe333/vy8/f33ItHPL18W+3WOJdC7PuNsd6/XmEBsJ/V8U89RbNe2+lz+vG2tz96ee39/956PJ5i7frsbjAABAgQIECBAgAABAvMK2GDOu7ZmRoAAAQIECBAgQIAAgV0FbDB35TYYAQIECBAgQIAAAQIE5hX4/Nf37596Tu/H29uvnvFbY/eeb+/4V/OM69v7nfHe78D3zj96xfbs9dl7ftEztnuvr/qM4m3t0T4/s+yr67l3fcb59K7XOF7a3nhmsHo9snzPVq/ZfLJ+9bntzKD6zCqsrb+352jf39Xz9QSzrd5cTYAAAQIECBAgQIAAAQIfCNhgfgDjywQIECBAgAABAgQIECDQJmCD2eblagIECBAgQIAAAQIECBD4QODh72B+cJ0vEzhEoPqd8DiJ2d+Bj/PVrhVQn7WeW6ON9v38cKZs578L2Ls+43qN5h/z014WeKjX5ctvrX9HMIZTn1FEe0lg7/pcykVfLuAJZm7kCgIECBAgQIAAAQIECBB4QsAG8wkklxAgQIAAAQIECBAgQIBALmCDmRu5ggABAgQIECBAgAABAgSeENj/DGb2d6i+fn0i7YVLYvydz7wsZPZUV/MZljjfOEqrZxYveGb57n3GIk5/tPbrt293Kf0MnnedGgR6C4Tv99cw3tnrM36/hendbq2fjw8Bar/g87LN05msNq/Wq9Vjq9j99erz3mPv1unqN/w8fvDa+vMqxu/8+6cnmA8r6AsECBAgQIAAAQIECBAgsEbABnONmnsIECBAgAABAgQIECBA4EHABvOBxBcIECBAgAABAgQIECBAYI3A/mcw12R54XteX16Gmn2WT/OZg6Fm9//JxHfUY35b34GP8a7e5n31Cph6/tN/Xg62eqc7czWYn3T6CqjPbb4+T7f57X23J5h7ixuPAAECBAgQIECAAAECkwrYYE66sKZFgAABAgQIECBAgACBvQVsMPcWNx4BAgQIECBAgAABAgQmFdj/DGbnM2xn/7ttzXVW7Vkdr3lCfW/I/m5n39Fvt8vVZ29Q8bcJhO/305+hDhrZ91t2pieE0wwCR3+ehnQ0CQwtEL9fRj+TGfMdGneG5MLP4+opZT8Pq8fzBLNaVDwCBAgQIECAAAECBAhcVMAG86ILb9oECBAgQIAAAQIECBCoFrDBrBYVjwABAgQIECBAgAABAhcV2P8MZgKdnQFqPTMz+jvuCcct88ju178s8FBP4R34Vv+HeMvD385en8n00vp9Dd4xXqt/vP9q7VavWK+x3RpvNO84n5jf2ecX53N0u9o7i3f0fPceP6vXzCu7f+/5jD5eq1f0j+3WeKP5xPnE/M4+vzif0dqZb7Y+cT69f//0BDOKaxMgQIAAAQIECBAgQIDAKgEbzFVsbiJAgAABAgQIECBAgACBKGCDGUW0CRAgQIAAAQIECBAgQGCVwHBnMFfNYqKber8TPRHVIVOJ6+PvRN0vQ/S5773dtnpl8eN4V29Hr63+s3tGr9nne/T8orf6vF+R6HPf6/M0evRux/VQr8vi0Wv5ar2zCXiCOduKmg8BAgQIECBAgAABAgQOErDBPAjesAQIECBAgAABAgQIEJhNwAZzthU1HwIECBAgQIAAAQIECBwksPsZzOzvuGQOW+/P4uu/lkB1PVXHm301eLWtcLVXdby22fS/evb59RdsG6Hauzpe22zOdzWvtjWr9qqO1zab/lfPPr/+gssjbPXdev9ydu29nmC2m7mDAAECBAgQIECAAAECBP4gYIP5BxRfIkCAAAECBAgQIECAAIF2ARvMdjN3ECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBpwQ+/Xh7+/XUlSsv+uv7908rby25be/57T1eCVJDkNnn10BxyktnX7/Z53fKomtIevb1m31+DUt9yktnX7/Z53fKomtIevb123t+e4/XsNQll/aen39FtmSZBCFAgAABAgQIECBAgAABG0w1QIAAAQIECBAgQIAAAQIlAjaYJYyCECBAgAABAgQIECBAgMDnSPD68hK/1NT++f7edP3eF+89v73Hm82z9zviVzsjHOtDfUaR+3b2eaY+771aW9n3n/pcFlWfx/4bEupTfS4JHP3zQX0urc7tln1+xrt5RpH7dvT0BPPeR4sAAQIECBAgQIAAAQIEVgrYYK6EcxsBAgQIECBAgAABAgQI3AvYYN57aBEgQIAAAQIECBAgQIDASoGHM5gr43x4W+930D8ceNKOq3t6B365sOM78MtX1/eqT2fYl6pKfS7p9O/z+blsrD6XfXr3qs9lYfW57HO23tl/X/IE82wVKV8CBAgQIECAAAECBAgMKmCDOejCSIsAAQIECBAgQIAAAQJnE7DBPNuKyZcAAQIECBAgQIAAAQKDCpSfwdz6Dv2gToelxbMv/ezvwPfVu93UZ19h9bnNV31u88vuVp+Z0HK/+lz22dqrPrcJqs9tfvHuq3l6ghkrQJsAAQIECBAgQIAAAQIEVgnYYK5icxMBAgQIECBAgAABAgQIRAEbzCiiTYAAAQIECBAgQIAAAQKrBMrPYK7Kwk0EdhK42jvwO7EapkhAfRZBCtNFQH12YRW0SEB9FkEKQ6BAwBPMAkQhCBAgQIAAAQIECBAgQOB2s8FUBQQIECBAgAABAgQIECBQImCDWcIoCAECBAgQIECAAAECBAjYYKoBAgQIECBAgAABAgQIECgRsMEsYRSEAAECBAgQIECAAAECBGww1QABAgQIECBAgAABAgQIlAjYYJYwCkKAAAECBAgQIECAAAECNphqgAABAgQIECBAgAABAgRKBGwwSxgFIUCAAAECBAgQIECAAAEbTDVAgAABAgQIECBAgAABAiUCNpgljIIQIECAAAECBAgQIECAgA2mGiBAgAABAgQIECBAgACBEgEbzBJGQQgQIECAAAECBAgQIEDABlMNECBAgAABAgQIECBAgECJgA1mCaMgBAgQIECAAAECBAgQIGCDqQYIECBAgAABAgQIECBAoETABrOEURACBAgQIECAAAECBAgQsMFUAwQIECBAgAABAgQIECBQImCDWcIoCAECBAgQIECAAAECBAh8jgSf/vknfqmp/evff5uub7149Pxa5xOvj/OLnll/jLe1nY2X9W8d3/19BeL6tY4W67P1/uz60fPL8te/TWD09R89v2367s4ERl//0fPLfPVvExh9/UfPb5u+uz3BVAMECBAgQIAAAQIECBAgUCJgg1nCKAgBAgQIECBAgAABAgQI2GCqAQIECBAgQIAAAQIECBAoEXg4g1kSVZDVAvFMW3xHPfavHujJG+N4R+cTx39yGr8vi/P53VH0P6PnVzRNYT4QGH39R8/vA1ZfLhIYff1Hz69oGYT5QGD09R89vw9YfZnAIQKeYB7CblACBAgQIECAAAECBAjMJ2CDOd+amhEBAgQIECBAgAABAgQOEbDBPITdoAQIECBAgAABAgQIEJhPwBnMwdY0vuMfzwxm/dXTycbL+qvzEY8AAQIECBAgQIDAngLx993WsePv8633Z9ePlp8nmNmK6SdAgAABAgQIECBAgACBpwRsMJ9ichEBAgQIECBAgAABAgQIZAI2mJmQfgIECBAgQIAAAQIECBB4SsAZzKeY9rsoe0c766/ONBsv66/ORzwCBAgQIECAAAECBMYV8ARz3LWRGQECBAgQIECAAAECBE4lYIN5quWSLAECBAgQIECAAAECBMYVsMEcd21kRoAAAQIECBAgQIAAgVMJPJzBHP1M3ej5nWr1JXt5gdG/n0bP7/IF1Blg9PUfPb/Oy3P58KOv/+j5Xb6AOgOMvv6j5xeXZ/R8R8vPE8xYQdoECBAgQIAAAQIECBAgsErABnMVm5sIECBAgAABAgQIECBAIArYYEYRbQIECBAgQIAAAQIECBBYJfBwBnNVFDcR2ElgtHfM47RHzy/mq10rMPr6j55f7WqIFgVGX//R84ue2rUCo6//6PnVroZoBLYJeIK5zc/dBAgQIECAAAECBAgQIPA/ARtMpUCAAAECBAgQIECAAAECJQI2mCWMghAgQIAAAQIECBAgQIDAwxnMn+/vpSqvLy+l8bJg1fln42X9vfO5um/mr39Z4Oz12Tv/ZT29vQVa1/f127fllL5+Xe4v7m3Nv3h44XoL/P338gg719tyMrebesyEJutXn6ULWv39M/vv755glpafYAQIECBAgAABAgQIELiugA3mddfezAkQIECAAAECBAgQIFAqYINZyikYAQIECBAgQIAAAQIErivw+a/v3z9VTv/H29uvynhbY1XPL8un93hX961+Bz6uZ+934nvnH+cT27PXZ+/5Rc/Y7r2+6vNefLTPw/vsHltH1+fNmazHRbnwVw6vx2ivPqPIpdtH12f1+KP9vKqeXyxWTzCjiDYBAgQIECBAgAABAgQIrBKwwVzF5iYCBAgQIECAAAECBAgQiAI2mFFEmwABAgQIECBAgAABAgRWCTz8HcxVUdxEoJNA9TviV3sHvtOyCPs/AfU5Vin8/PKlKaHeZ1pjMtnnT3U9xfHP3h7Np7XeMv+96zHLR3+bgPps83L13AKeYM69vmZHgAABAgQIECBAgACB3QRsMHejNhABAgQIECBAgAABAgTmFrDBnHt9zY4AAQIECBAgQIAAAQK7CfQ/gxn/rtHXr9smF+PFaI1ncOLtR7ezMzoP+WUerd5ZvOCb5TvamYTo9/rt2/2XWr3u79YiUCrwUJ8x+sXrNX6+ZJ9Hka93O1u/6jN82Xyqx7vamcFYb5l31j9avWb59u5Xn9uEW+tT/W3z3nx3/H1768/zGC8mGH5/j93VbU8wq0XFI0CAAAECBAgQIECAwEUFbDAvuvCmTYAAAQIECBAgQIAAgWoBG8xqUfEIECBAgAABAgQIECBwUYH+ZzAvCls17dHOuGT5/Hx/r5r6OeMM9g788IiZ19YzCcMDSLCnQPZ51XPsEWK3nsnKcnZmKxPS3yKgPlu0+l979c/L/sLXGsETzGutt9kSIECAAAECBAgQIECgm4ANZjdagQkQIECAAAECBAgQIHAtARvMa6232RIgQIAAAQIECBAgQKCbQPczmPHvGm1+x9uZrPtiqPaojnef7XCt8vpsnGE801R9JqUxHZcPJnB0fQ7Gcbp04vqdbgKDJezzcrAFOTidWA8Hp2P4YoFsfc/++1L8+TDb/sgTzOJvCOEIECBAgAABAgQIECBwVQEbzKuuvHkTIECAAAECBAgQIECgWMAGsxhUOAIECBAgQIAAAQIECFxVoPwMZnwnOnuHOsJnf0dx8zvKccDB25nH4OkPl17v+rx9+XI351ivsT37+mbze03O/Gb332FP2Ij1EqfY6pPFi/HP3m71qZ5v5n10ftXzjfFa5xe9Yrs1Xsxn9HY2v+gR55PdH6+frV3tk8Wbze/o+sm8j85v63r3/v0z89uaf+v9nmC2irmeAAECBAgQIECAAAECBP4oYIP5RxZfJECAAAECBAgQIECAAIFWARvMVjHXEyBAgAABAgQIECBAgMAfBcrPYP5xFF98WiC+o/30jS48RCCuV+uZ40OS7jho9IhDbfXJ4sfxrtaOPlu9z+YX5793/lfzbvWN63N1r+gRPbf6ZPHjeFdrR5+t3mfzi/PfO/+ree/te/R4nmAevQLGJ0CAAAECBAgQIECAwCQCNpiTLKRpECBAgAABAgQIECBA4GgBG8yjV8D4BAgQIECAAAECBAgQmERg9zOYW/+Ozdb7J1k30+gkUF1f1fE6TfuwsHyW6at9quMtZ693du/q+VXHm60C+SyvaLVPdbzl7PVe3Xvr/LfeX12BnmBWi4pHgAABAgQIECBAgACBiwrYYF504U2bAAECBAgQIECAAAEC1QI2mNWi4hEgQIAAAQIECBAgQOCiAv8HukM8fBoMw90AAAAASUVORK5CYII=');
    background-size: 352px 64px; /* 11 frames x 32px, 2 rows */
    z-index: 9999;
    transition: left 0.1s, bottom 0.1s;
}

.pig-sprite.facing-left {
    transform: scaleX(-1);
}

.pig-sprite.jumping {
    animation: jump 0.5s ease-out;
}

@keyframes jump {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-50px); }
}

.curriculum-overview {
    padding: 20px;
}

.units-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.unit-card {
    background: white;
    border: 2px solid #e0e0e0;
    border-radius: 12px;
    padding: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.unit-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
    border-color: #3498db;
}

.unit-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.unit-header h3 {
    margin: 0;
    color: #2c3e50;
}

.completion-badge {
    background: #4CAF50;
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
}

.unit-title {
    color: #666;
    font-size: 14px;
    margin-bottom: 15px;
    min-height: 40px;
}

.unit-stats {
    display: flex;
    gap: 10px;
    font-size: 13px;
    color: #999;
    margin-bottom: 15px;
}

.progress-bar {
    height: 6px;
    background: #f0f0f0;
    border-radius: 3px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    transition: width 0.3s ease;
}
    </style>
</head>
<body>
    <div class="container">
        <h1>🧮 AP Statistics Consensus Quiz</h1>
        <div id="messageArea"></div>
        <div id="questionsContainer"></div>
    </div>

    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">🌙</button>

    <script>
        // Curriculum data will be loaded from external files
    //let EMBEDDED_CURRICULUM = [];
    //let ALL_UNITS_DATA = [];

        // Enhanced dynamic loading function with comprehensive error handling
        function loadCurriculumResources() {
            return new Promise((resolve, reject) => {
                let loadedCount = 0;
                const totalResources = 2;
                let hasErrors = false;

                // Check if resources are already loaded
                if (window.EMBEDDED_CURRICULUM && window.EMBEDDED_CURRICULUM.length > 0 &&
                    window.ALL_UNITS_DATA && window.ALL_UNITS_DATA.length > 0) {
                    console.log('Curriculum resources already loaded');
                    resolve();
                    return;
                }

                // Function to check if all resources are loaded
                const checkLoaded = () => {
                    loadedCount++;
                    console.log(`Resource ${loadedCount}/${totalResources} loaded`);

                    if (loadedCount === totalResources) {
                        if (!hasErrors && window.EMBEDDED_CURRICULUM && window.ALL_UNITS_DATA) {
                            console.log('All curriculum resources loaded successfully');
                            resolve();
                        } else {
                            reject(new Error('Failed to load all curriculum resources'));
                        }
                    }
                };

                const handleError = (resourceName, error) => {
                    console.error(`Failed to load ${resourceName}:`, error);
                    hasErrors = true;
                    checkLoaded(); // Still count as loaded to continue with partial functionality
                };

                // Load embeddedCurriculum.js
                const script1 = document.createElement('script');
                script1.src = 'embeddedCurriculum.js';
                script1.onload = () => {
                    if (typeof EMBEDDED_CURRICULUM !== 'undefined' && EMBEDDED_CURRICULUM.length > 0) {
                        console.log('EMBEDDED_CURRICULUM loaded from embeddedCurriculum.js');
                        checkLoaded();
                    } else {
                        handleError('EMBEDDED_CURRICULUM', new Error('EMBEDDED_CURRICULUM is not properly defined'));
                    }
                };
                script1.onerror = () => handleError('embeddedCurriculum.js', new Error('Script failed to load'));

                // Load allUnitsData.js
                const script2 = document.createElement('script');
                script2.src = 'allUnitsData.js';
                script2.onload = () => {
                    if (typeof ALL_UNITS_DATA !== 'undefined' && ALL_UNITS_DATA.length > 0) {
                        console.log('ALL_UNITS_DATA loaded from allUnitsData.js');
                        checkLoaded();
                    } else {
                        handleError('ALL_UNITS_DATA', new Error('ALL_UNITS_DATA is not properly defined'));
                    }
                };
                script2.onerror = () => handleError('allUnitsData.js', new Error('Script failed to load'));

                // Append scripts to document head
                document.head.appendChild(script1);
                document.head.appendChild(script2);

                // Set a timeout as fallback
                setTimeout(() => {
                    if (loadedCount < totalResources) {
                        console.warn('Timeout reached while loading curriculum resources');
                        if (window.EMBEDDED_CURRICULUM || window.ALL_UNITS_DATA) {
                            console.log('Partial resources loaded, proceeding with available data');
                            resolve();
                        } else {
                            reject(new Error('Timeout: No curriculum resources loaded'));
                        }
                    }
                }, 10000); // 10 second timeout
            });
        }
        // Helper functions for charts
        function generateChartColors(count) {
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
            ];
            const result = [];
            for (let i = 0; i < count; i++) {
                result.push(colors[i % colors.length]);
            }
            return result;
        }

        function isDarkMode() {
            return document.body.classList.contains('dark-theme');
        }

        function getTextColor() {
            return isDarkMode() ? '#e0e0e0' : '#333333';
        }

        function getGridColor() {
            return isDarkMode() ? '#444444' : '#e0e0e0';
        }

        function getScatterPointColor() {
            return isDarkMode() ? '#5BC0EB' : '#36A2EB';
        }

        // Username Generation
        const fruits = ['Apple', 'Banana', 'Cherry', 'Grape', 'Lemon', 'Mango', 'Orange', 'Peach', 'Pear', 'Plum', 'Berry', 'Melon', 'Kiwi', 'Lime', 'Papaya', 'Guava', 'Apricot', 'Date', 'Fig', 'Coconut'];
        const animals = ['Bear', 'Cat', 'Dog', 'Eagle', 'Fox', 'Goat', 'Horse', 'Iguana', 'Jaguar', 'Koala', 'Lion', 'Monkey', 'Newt', 'Owl', 'Panda', 'Quail', 'Rabbit', 'Snake', 'Tiger', 'Wolf'];

        function generateRandomUsername() {
            const fruit = fruits[Math.floor(Math.random() * fruits.length)];
            const animal = animals[Math.floor(Math.random() * animals.length)];
            return `${fruit}_${animal}`;
        }

        function getDeviceId() {
            // Check if deviceId is already stored in localStorage
            let deviceId = localStorage.getItem('deviceId');
            if (!deviceId) {
                // Generate a unique device ID based on browser fingerprint and timestamp
                const fingerprint = [
                    navigator.userAgent,
                    navigator.language,
                    screen.width + 'x' + screen.height,
                    new Date().getTimezoneOffset(),
                    Date.now().toString()
                ].join('|');

                // Create a simple hash of the fingerprint
                let hash = 0;
                for (let i = 0; i < fingerprint.length; i++) {
                    const char = fingerprint.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }

                deviceId = 'device_' + Math.abs(hash).toString(36) + '_' + Date.now().toString(36);
                localStorage.setItem('deviceId', deviceId);
            }
            return deviceId;
        }

        // Advanced compression function with multiple optimization techniques
        function compressData() {
            const cutoff = classData.lastSyncTime || 0;
            const user = classData.users[currentUsername];

            if (!user || !user.answers) return '';

            const changes = {};
            const now = Date.now();

            // Collect all recent changes
            const recentChanges = [];
            Object.keys(user.answers).forEach(qId => {
                if (user.timestamps[qId] > cutoff) {
                    recentChanges.push({
                        id: qId,
                        answer: user.answers[qId],
                        timestamp: user.timestamps[qId],
                        reason: user.reasons?.[qId] || '',
                        attempts: user.attempts?.[qId] || 0
                    });
                }
            });

            // Sort by timestamp for better compression
            recentChanges.sort((a, b) => a.timestamp - b.timestamp);

            // Process each change with advanced compression
            recentChanges.forEach(change => {
                // Use shortest possible ID
                let shortId = change.id.split('-').pop();
                if (/^\d+$/.test(shortId)) {
                    shortId = parseInt(shortId).toString(36); // Convert to base36 for shorter numbers
                }

                // Compress answer value
                let compressedAnswer = change.answer;
                if (typeof compressedAnswer === 'string') {
                    // Compress common answer patterns
                    compressedAnswer = compressedAnswer
                        .replace(/^option\s*(\d+)$/i, 'o$1')  // "option 1" -> "o1"
                        .replace(/^choice\s*(\d+)$/i, 'c$1')   // "choice 1" -> "c1"
                        .replace(/^answer\s*(\d+)$/i, 'a$1');  // "answer 1" -> "a1"
                }

                // Use delta encoding for timestamp (relative to export time)
                const deltaTime = now - change.timestamp;

                // Create compressed change object
                const compressedChange = [compressedAnswer, deltaTime];

                // Add optional fields only if non-empty/non-zero
                if (change.reason) {
                    compressedChange.push(change.reason);
                }
                if (change.attempts > 0) {
                    compressedChange.push(change.attempts);
                }

                changes[shortId] = compressedChange;
            });

            // Create packet with compressed metadata
            const packet = {
                d: getDeviceId().split('_').pop(),  // Short device ID
                u: currentUsername,
                s: cutoff,
                e: now,
                c: changes
            };

            // Advanced compression: remove quotes and use array format
            let compressed = JSON.stringify(packet);

            // Apply multiple compression passes
            compressed = compressed
                // Remove quotes from single-letter keys
                .replace(/"([a-z])":/g, '$1:')
                // Compress common timestamp patterns
                .replace(/,"t":(\d+)/g, ',$1')
                // Remove unnecessary whitespace
                .replace(/\s+/g, '');

            return btoa(compressed);
        }

        // Advanced decompression function (for receiving end)
        function decompressData(compressedData) {
            try {
                // Decode base64
                const decoded = atob(compressedData);

                // Restore quotes around keys for JSON parsing
                const jsonStr = decoded
                    .replace(/([{,]\s*)([a-z]):/g, '$1"$2":')
                    .replace(/changes:/g, '"changes":');

                const packet = JSON.parse(jsonStr);

                // Reconstruct full device ID
                const fullDeviceId = packet.d.startsWith('dev_') ? packet.d : `dev_${packet.d}`;

                // Convert back to full format
                return {
                    deviceId: fullDeviceId,
                    username: packet.u,
                    since: packet.s,
                    exported: packet.e,
                    changes: Object.keys(packet.c).reduce((acc, shortId) => {
                        const compressedChange = packet.c[shortId];

                        // Reconstruct full question ID
                        let fullId;
                        if (/^\d+$/.test(shortId)) {
                            // If shortId is numeric, it was converted from base36
                            const numericId = parseInt(shortId, 36);
                            fullId = `question-${numericId}`;
                        } else {
                            fullId = `question-${shortId}`;
                        }

                        // Decompress answer value
                        let decompressedAnswer = compressedChange[0];
                        if (typeof decompressedAnswer === 'string') {
                            // Decompress common answer patterns
                            decompressedAnswer = decompressedAnswer
                                .replace(/^o(\d+)$/i, 'option $1')  // "o1" -> "option 1"
                                .replace(/^c(\d+)$/i, 'choice $1')   // "c1" -> "choice 1"
                                .replace(/^a(\d+)$/i, 'answer $1');  // "a1" -> "answer 1"
                        }

                        // Reconstruct timestamp from delta
                        const timestamp = packet.e - compressedChange[1];

                        // Extract optional fields
                        const reason = compressedChange[2] || '';
                        const attempts = compressedChange[3] || 0;

                        acc[fullId] = {
                            answer: decompressedAnswer,
                            timestamp: timestamp,
                            reason: reason,
                            attempts: attempts
                        };
                        return acc;
                    }, {})
                };
            } catch (e) {
                console.error('Failed to decompress data:', e);
                return null;
            }
        }

        function exportForQR() {
            const cutoffTime = classData.lastSyncTime || 0;
            const packet = {
                deviceId: getDeviceId(),
                username: currentUsername,
                since: cutoffTime,
                exported: Date.now(),
                changes: {}
            };

            // Only export answers newer than last sync
            const user = classData.users[currentUsername];
            if (user && user.answers) {
                Object.keys(user.answers).forEach(qId => {
                    // Check if timestamp exists and is newer than cutoff
                    if (user.timestamps && user.timestamps[qId] && user.timestamps[qId] > cutoffTime) {
                        packet.changes[qId] = {
                            answer: user.answers[qId],
                            reason: user.reasons ? user.reasons[qId] : '',
                            timestamp: user.timestamps[qId],
                            attempts: user.attempts ? user.attempts[qId] : 0
                        };
                    }
                });
            }

            // Try compression first
            const compressed = compressData();
            if (compressed && compressed.length <= 2000) {
                return compressed;
            }

            // Fallback to original method if compression fails or is too long
            const json = JSON.stringify(packet);
            if (json.length > 2000) {
                // Show warning: "Too many changes since last sync. Use file export."
                return null;
            }

            return btoa(json);
        }

        // Global variables
        let currentUsername = null;
        let classData = null;
        let currentUnit = null;
        let currentLesson = null;
        let currentQuestions = [];
        let allUnitQuestions = [];
        let chartInstances = {};
        let currentTheme = 'light';

        // Add this to your global variables
        let allCurriculumData = {}; // Store all units' data

        // First, make sure QRSyncManager is defined BEFORE you try to use it
        // Add this right after your other global variables at the top
        let qrSync = null;

        // Unit structure - defines lessons per unit
        const unitStructure = {
            1: { name: 'Exploring One-Variable Data', lessons: 5 },
            2: { name: 'Exploring Two-Variable Data', lessons: 4 },
            3: { name: 'Collecting Data', lessons: 3 },
            4: { name: 'Probability & Random Variables', lessons: 5 },
            5: { name: 'Sampling Distributions', lessons: 4 },
            6: { name: 'Inference for Proportions', lessons: 4 },
            7: { name: 'Inference for Means', lessons: 4 },
            8: { name: 'Chi-Square Tests', lessons: 2 },
            9: { name: 'Inference for Slopes', lessons: 2 }
        };

        // When loading classData, add new fields only if missing:
        function initClassData() {
            let classDataStr = localStorage.getItem('classData');
            classData = classDataStr ? JSON.parse(classDataStr) : {users: {}};

            // Add new fields without disrupting old data
            classData.lastSyncTime = classData.lastSyncTime || 0;
            classData.syncHistory = classData.syncHistory || [];
            classData.deviceId = classData.deviceId || generateDeviceId();

            // Ensure user structure is complete
            if (!classData.users[currentUsername]) {
                classData.users[currentUsername] = {
                    answers: {},
                    reasons: {},
                    timestamps: {},
                    attempts: {}
                };
            }

            saveClassData();
        }

        function generateDeviceId() {
            return 'dev_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function saveClassData() {
            try {
                localStorage.setItem('classData', JSON.stringify(classData));
            } catch(e) {
                console.log("Storage quota exceeded");
                showMessage("Warning: Local storage is full. Some data may not be saved.", 'error');
            }
        }

        // Student Performance Badges
        function calculateBadges(username) {
            const userAnswers = classData.users[username]?.answers || {};
            const userReasons = classData.users[username]?.reasons || {};
            const userAttempts = classData.users[username]?.attempts || {};

            const totalAnswers = Object.keys(userAnswers).length;
            if (totalAnswers === 0) return [];

            const badges = [];

            // Calculate outlier/conformist
            let modeMatches = 0;
            let outlierCount = 0;

            Object.keys(userAnswers).forEach(qId => {
                const allAnswers = Object.values(classData.users)
                    .map(u => u.answers?.[qId]?.value || u.answers?.[qId])
                    .filter(a => a);

                if (allAnswers.length > 1) {
                    const mode = getMostFrequent(allAnswers);
                    const userAnswer = userAnswers[qId]?.value || userAnswers[qId];
                    if (userAnswer === mode) modeMatches++;
                    else outlierCount++;
                }
            });

            if (outlierCount > totalAnswers * 0.5) badges.push('🎯 Outlier');
            if (modeMatches > totalAnswers * 0.8) badges.push('👥 Conformist');

            // Explorer badge
            const multiAttempts = Object.values(userAttempts).filter(a => a >= 2).length;
            if (multiAttempts > totalAnswers * 0.3) badges.push('🔄 Explorer');

            // Silent type vs Debater
            const reasonCount = Object.values(userReasons).filter(r => r && r.trim()).length;
            if (reasonCount < totalAnswers * 0.2) badges.push('🤐 Silent Type');
            else if (reasonCount > totalAnswers * 0.8) badges.push('💬 Debater');

            // Completionist
            const totalQuestions = currentQuestions.length;
            if (totalAnswers === totalQuestions && totalQuestions > 0) badges.push('✅ Completionist');

            return badges;
        }

        function getMostFrequent(arr) {
            const counts = {};
            arr.forEach(x => counts[x] = (counts[x] || 0) + 1);
            return Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
        }

        // Check if question has been answered
        function isQuestionAnswered(questionId) {
            return classData.users[currentUsername]?.answers?.[questionId] !== undefined;
        }

        // Get attempt count for a question
        function getAttemptCount(questionId) {
            return classData.users[currentUsername]?.attempts?.[questionId] || 0;
        }

        // Check if can retry (has reason in previous attempt and < 3 attempts)
        function canRetry(questionId) {
            const attempts = getAttemptCount(questionId);
            if (attempts >= 3) return false;
            if (attempts === 0) return true;
            
            // Check if previous attempt had a reason
            const previousReason = classData.users[currentUsername]?.reasons?.[questionId];
            return previousReason && previousReason.trim().length > 0;
        }
        // Replace the entire detectUnitAndLessons function:
        function detectUnitAndLessons(questions) {
            if (!questions || questions.length === 0) return null;

            const firstId = questions[0].id;
            const unitMatch = firstId.match(/U(\d+)/i);
            if (!unitMatch) return null;

            const unitNum = parseInt(unitMatch[1]);

            // Group questions by lesson
            const lessonGroups = {};
            questions.forEach(q => {
                let lessonIdentifier;

                // Check for Progress Check questions first
                if (q.id.includes('-PC-')) {
                    lessonIdentifier = 'PC';
                } else {
                    // Match standard lesson format: U#-L#-
                    const lessonMatch = q.id.match(/U\d+-L(\d+)-/);
                    if (lessonMatch) {
                        lessonIdentifier = parseInt(lessonMatch[1]);
                    }
                }

                if (lessonIdentifier !== undefined) {
                    if (!lessonGroups[lessonIdentifier]) {
                        lessonGroups[lessonIdentifier] = [];
                    }
                    lessonGroups[lessonIdentifier].push(q);
                }
            });

            // Sort lesson numbers properly, with PC at the end
            const numericLessons = Object.keys(lessonGroups)
                .filter(key => typeof key === 'number' || !isNaN(key))
                .map(n => parseInt(n))
                .sort((a, b) => a - b);

            const allLessons = numericLessons.concat(lessonGroups['PC'] ? ['PC'] : []);

            console.log('Detected lessons:', allLessons); // Debug log
            console.log('Lesson groups:', Object.keys(lessonGroups)); // Debug log

            return {
                unitNumber: unitNum,
                lessons: lessonGroups,
                lessonNumbers: allLessons
            };
        }

        // Modified loadFromFile function
        function loadFromFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                showMessage('Please select a unit JSON file', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    const questions = Array.isArray(data) ? data : (data.questions || []);

                    const unitInfo = detectUnitAndLessons(questions);
                    if (!unitInfo) {
                        showMessage('Could not detect unit from question IDs', 'error');
                        return;
                    }

                    currentUnit = unitInfo.unitNumber;
                    allUnitQuestions = questions;

                    // Show unit name if available
                    const unitName = unitStructure[currentUnit]?.name || `Unit ${currentUnit}`;
                    showMessage(`Loaded ${unitName} with ${unitInfo.lessonNumbers.length} lessons`, 'success');

                    // Go directly to lesson selector
                    renderLessonSelector(unitInfo);
                } catch (error) {
                    showMessage('Error parsing JSON: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

       

        // Add simple file upload UI at start
        function renderFileUpload() {
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <h2>Load a Unit File</h2>
                    <p style="margin-bottom: 20px;">Select a unit JSON file (unit1.json, unit2.json, etc.)</p>
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <input type="file" id="fileInput" accept=".json"
                               style="padding: 10px; font-size: 16px;">
                    </div>
                    <button onclick="loadFromFile()" class="submit-button" style="padding: 12px 30px;">
                        Load Unit File
                    </button>
                    <div style="margin-top: 30px; padding: 15px; background: #e3f2fd; border-radius: 8px;">
                        <strong>Note:</strong> The app will automatically detect which unit you've loaded based on question IDs (U1, U2, etc.)
                    </div>
                </div>
            `;
        }

        // New function to go back to file upload
        window.backToFileUpload = function() {
            // Clear current data
            currentUnit = null;
            currentLesson = null;
            currentQuestions = [];
            allUnitQuestions = [];

            // Clear charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};

            renderFileUpload();
        }

        // Username management
        function promptUsername() {
            // Check URL parameters first
            const urlParams = new URLSearchParams(window.location.search);
            const urlUsername = urlParams.get('user');

            if (urlUsername) {
                // Use username from URL
                currentUsername = urlUsername;
                localStorage.setItem('consensusUsername', urlUsername);
                initClassData();
                showUsernameWelcome();
                loadEmbeddedCurriculum();

                // Clean up URL (optional - removes the parameter from address bar)
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }

            // Rest of existing promptUsername code...
            const savedUsername = localStorage.getItem('consensusUsername');
            if (savedUsername) {
                currentUsername = savedUsername;
                initClassData();
                showUsernameWelcome();

                // AUTO-LOAD EMBEDDED DATA instead of showing file upload
                loadEmbeddedCurriculum();  // Add this new function
            } else {
                showUsernamePrompt();
            }
        }

        function showUsernamePrompt() {
            const suggestedName = generateRandomUsername();
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = `
                <div class="username-prompt">
                    <h2>Welcome to AP Statistics Consensus Quiz</h2>
                    <p>Your generated username:</p>
                    <div style="font-size: 24px; font-weight: bold; color: #3498db; margin: 15px;">${suggestedName}</div>
                    <button onclick="acceptUsername('${suggestedName}')" class="start-button">Accept This Name</button>
                    <button onclick="rerollUsername()" class="start-button" style="background: #7f8c8d;">Generate New Name</button>
                </div>
            `;
        }

        window.rerollUsername = function() {
            showUsernamePrompt();
        }

        window.acceptUsername = function(name) {
            currentUsername = name;
            localStorage.setItem('consensusUsername', currentUsername);
            initClassData();
            showUsernameWelcome();

            // AUTO-LOAD instead of file upload
            loadEmbeddedCurriculum();
        }

        function loadEmbeddedCurriculum() {
            // Parse embedded curriculum
            allCurriculumData = {};
            const allQuestions = EMBEDDED_CURRICULUM.questions || EMBEDDED_CURRICULUM;

            // Group by units
            const unitGroups = {};
            allQuestions.forEach(question => {
                const unitMatch = question.id.match(/U(\d+)/i);
                if (unitMatch) {
                    const unitNum = parseInt(unitMatch[1]);
                    if (!unitGroups[unitNum]) {
                        unitGroups[unitNum] = [];
                    }
                    unitGroups[unitNum].push(question);
                }
            });

            // Process each unit
            Object.keys(unitGroups).forEach(unitNum => {
                const unitQuestions = unitGroups[unitNum];
                const unitInfo = detectUnitAndLessons(unitQuestions);
                if (unitInfo) {
                    allCurriculumData[unitNum] = {
                        questions: unitQuestions,
                        unitInfo: unitInfo,
                        fileName: `Unit ${unitNum}`
                    };
                }
            });

            // Go straight to unit menu
            renderUnitMenu();
        }

        function showUsernameWelcome() {
            const container = document.querySelector('.container');
            if (!container) return;
            const existingWelcome = document.querySelector('.username-welcome');
            if (existingWelcome) existingWelcome.remove();

            const welcomeDiv = document.createElement('div');
            welcomeDiv.className = 'username-welcome';
            welcomeDiv.textContent = `Welcome ${currentUsername}!`;
            container.insertBefore(welcomeDiv, container.firstChild.nextSibling);
        }

        // Unit selector - REMOVED: No longer needed due to CORS issues
        // function renderUnitSelector() {
        //     const questionsContainer = document.getElementById('questionsContainer');
        //     let buttonsHtml = '';
        //
        //     for (let unitNum in unitStructure) {
        //         const unit = unitStructure[unitNum];
        //         buttonsHtml += `
        //             <button onclick="loadUnit(${unitNum})" class="unit-btn" id="unit-btn-${unitNum}">
        //                 <strong>Unit ${unitNum}</strong><br>
        //                 ${unit.name}
        //             </button>
        //         `;
        //     }
        //
        //     questionsContainer.innerHTML = `
        //         <div class="unit-selector">
        //             <h2>Select a Unit</h2>
        //             <div class="unit-buttons">
        //                 ${buttonsHtml}
        //             </div>
        //         </div>
        //     `;
        // }

        // Load unit
        window.loadUnit = async function(unitNumber) {
            const btn = document.getElementById(`unit-btn-${unitNumber}`);
            if (btn) {
                btn.classList.add('loading');
                btn.disabled = true;
            }

            try {
                const response = await fetch(`unit${unitNumber}.json`);
                if (!response.ok) {
                    throw new Error(`Unit ${unitNumber} file not found`);
                }
                const data = await response.json();
                currentUnit = unitNumber;
                allUnitQuestions = Array.isArray(data) ? data : (data.questions || []);
                
                renderLessonSelector();
                showMessage(`Unit ${unitNumber} loaded successfully!`, 'success');
            } catch (error) {
                showMessage(`Error loading Unit ${unitNumber}: ${error.message}`, 'error');
                if (btn) {
                    btn.classList.remove('loading');
                    btn.disabled = false;
                }
            }
        }

        // Render lesson selector
function renderLessonSelector(unitInfo) {
    const questionsContainer = document.getElementById('questionsContainer');
    
    // If unitInfo provided (from file load), use it
    if (unitInfo && unitInfo.lessonNumbers) {
        let lessonButtonsHtml = '';
        
        unitInfo.lessonNumbers.forEach(lessonNum => {
            const questions = unitInfo.lessons[lessonNum];
            const isCompleted = questions.every(q => isQuestionAnswered(q.id));
            const displayName = lessonNum === 'PC' ? 'Progress Check' : `Lesson ${lessonNum}`;
            const buttonId = lessonNum === 'PC' ? 'lesson-btn-PC' : `lesson-btn-${lessonNum}`;

            lessonButtonsHtml += `
                <button onclick="loadLesson('${lessonNum}')"
                        class="lesson-btn ${isCompleted ? 'completed' : ''}"
                        id="${buttonId}">
                    ${displayName}<br>
                    <small>${questions.length} questions</small>
                </button>
            `;
        });
        
        questionsContainer.innerHTML = `
            <button onclick="backToUnits()" class="back-button">← Back to Units</button>
            <div class="lesson-selector">
                <h3>Unit ${currentUnit}: ${unitStructure[currentUnit]?.name || 'Unknown Unit'}</h3>
                <p>Select a lesson to begin:</p>
                <div class="lesson-buttons">
                    ${lessonButtonsHtml}
                </div>
            </div>
            <div class="app-controls">
                ${renderSyncButtons()}
            </div>
        `;
        return;
    }
    
    // Old fallback code for when called without unitInfo
    const unit = unitStructure[currentUnit];
    if (!unit) return;
    
    let lessonButtonsHtml = '';
    
    // Group questions by lesson
    const lessonGroups = {};
    allUnitQuestions.forEach(q => {
        const match = q.id.match(/L(\d+)/);
        if (match) {
            const lessonNum = parseInt(match[1]);
            if (!lessonGroups[lessonNum]) {
                lessonGroups[lessonNum] = [];
            }
            lessonGroups[lessonNum].push(q);
        }
    });
    
    for (let i = 1; i <= unit.lessons; i++) {
        const questionCount = lessonGroups[i] ? lessonGroups[i].length : 0;
        const isCompleted = checkLessonCompleted(currentUnit, i);
        lessonButtonsHtml += `
            <button onclick="loadLesson(${i})" class="lesson-btn ${isCompleted ? 'completed' : ''}" id="lesson-btn-${i}">
                Lesson ${i}<br>
                <small>${questionCount} questions</small>
            </button>
        `;
    }
    
    questionsContainer.innerHTML = `
        <button onclick="backToUnits()" class="back-button">← Back to Units</button>
        <div class="lesson-selector">
            <h3>Unit ${currentUnit}: ${unit.name}</h3>
            <p>Select a lesson to begin:</p>
            <div class="lesson-buttons">
                ${lessonButtonsHtml}
            </div>
        </div>
        <div class="app-controls">
            ${renderSyncButtons()}
        </div>
    `;
}

        // Check if lesson is completed
        function checkLessonCompleted(unitNum, lessonNum) {
            const lessonQuestions = allUnitQuestions.filter(q => {
                const match = q.id.match(/L(\d+)/);
                return match && parseInt(match[1]) === lessonNum;
            });
            
            if (lessonQuestions.length === 0) return false;
            
            return lessonQuestions.every(q => isQuestionAnswered(q.id));
        }

        // Load lesson
        window.loadLesson = function(lessonNumber) {
            currentLesson = lessonNumber;

            // Handle both numeric lessons and 'PC'
            if (lessonNumber === 'PC') {
                currentQuestions = allUnitQuestions.filter(q => q.id.includes('-PC-'));
            } else {
                const lessonNum = parseInt(lessonNumber);
                currentQuestions = allUnitQuestions.filter(q => {
                    if (q.id.includes('-PC-')) return false; // Exclude PC questions
                    const match = q.id.match(/U\d+-L(\d+)-/);
                    return match && parseInt(match[1]) === lessonNum;
                });
            }

            if (currentQuestions.length === 0) {
                showMessage(`No questions found for Lesson ${lessonNumber}`, 'error');
                return;
            }

            console.log(`Loading lesson ${lessonNumber} with ${currentQuestions.length} questions`); // Debug
            renderQuiz();
        }

        // Back to units
        window.backToUnits = function() {
            // Clear any existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};
            currentQuestions = [];
            allUnitQuestions = [];
            currentUnit = null;
            currentLesson = null;

            // Go to file upload instead of unit selector
            renderFileUpload();
        }

        // Back to lessons
        window.backToLessons = function() {
            // Clear any existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};
            currentQuestions = [];
            currentLesson = null;

            // Re-detect the unit structure from allUnitQuestions
            const unitInfo = detectUnitAndLessons(allUnitQuestions);

            // Call renderLessonSelector with the unitInfo
            renderLessonSelector(unitInfo);
        }

        // Render quiz
        function renderQuiz() {
            const questionsContainer = document.getElementById('questionsContainer');
            
            questionsContainer.innerHTML = `
                <button onclick="backToLessons()" class="back-button">← Back to Lessons</button>
                <div class="app-controls">
                    <div style="flex: 1;">
                        <strong>Unit ${currentUnit}, Lesson ${currentLesson}</strong> - ${currentQuestions.length} questions
                    </div>
                    ${renderSyncButtons()}
                </div>
                <div id="questions-list"></div>
                <div class="loading-msg" id="loading-msg" style="display:none;">Loading questions...</div>
            `;
            
            const questionsList = document.getElementById('questions-list');
            
            // Show loading message
            document.getElementById('loading-msg').style.display = 'block';
            
            // Render all questions for the lesson with a small delay for animation
            setTimeout(() => {
                currentQuestions.forEach((question, index) => {
                    const questionHtml = renderQuestion(question, index);
                    questionsList.insertAdjacentHTML('beforeend', questionHtml);
                });
                
                document.getElementById('loading-msg').style.display = 'none';
                
                // Load saved progress
                loadProgress();
                
                // Render MathJax
                if (window.MathJax) {
                    MathJax.typesetPromise().catch(e => console.log('MathJax error:', e));
                }
                
                // Render charts for visible questions
                setTimeout(renderVisibleCharts, 100);
            }, 100);
        }

        // Render question
        function renderQuestion(question, index) {
            const questionNumber = index + 1;
            const isAnswered = isQuestionAnswered(question.id);
            const attempts = getAttemptCount(question.id);
            const canRetryQuestion = canRetry(question.id);
            
            let html = `
                <div class="quiz-container" data-question-id="${question.id}" data-question-number="${questionNumber}">
                    <div class="question-header">
                        <span>Question ${questionNumber}</span>
                        ${isAnswered ? '<span style="color: #a5d6a7;">✓ Answered</span>' : ''}
                    </div>
                    <div class="question-id">ID: ${question.id || 'N/A'}</div>
                    <div class="question-prompt">${question.prompt || 'No prompt provided'}</div>
            `;

            // Render attachments if present
            if (question.attachments) {
                html += renderAttachments(question.attachments, question.id);
            }

            // Handle MCQ
            if (question.type === 'multiple-choice') {
                const choices = question.choices || question.attachments?.choices || [];
                const savedAnswer = classData.users[currentUsername]?.answers?.[question.id];
                const isDisabled = isAnswered && !canRetryQuestion;
                
                html += '<div class="choices">';
                choices.forEach(choice => {
                    const isSelected = savedAnswer?.value === choice.key || savedAnswer === choice.key;
                    html += `
                        <div class="choice ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}">
                            <label>
                                <input type="radio" 
                                       name="choice-${question.id}" 
                                       value="${choice.key}"
                                       ${isSelected ? 'checked' : ''}
                                       ${isDisabled ? 'disabled' : ''}>
                                <span class="choice-key">${choice.key}.</span>
                                <span>${choice.value}</span>
                            </label>
                        </div>
                    `;
                });
                html += '</div>';
            }

            // Handle FRQ
            if (question.type === 'free-response') {
                const savedAnswer = classData.users[currentUsername]?.answers?.[question.id];
                const isDisabled = isAnswered && !canRetryQuestion;
                html += `
                    <div class="answer-section">
                        <textarea
                            id="frq-${question.id}"
                            class="frq-textarea"
                            placeholder="Enter your complete response here..."
                            ${isDisabled ? 'disabled' : ''}
                            style="width: 100%; min-height: 200px; padding: 10px; border: 2px solid #ddd;"
                        >${savedAnswer?.value || savedAnswer || ''}</textarea>
                    </div>
                `;
            }

            // Add answer section
            html += `
                <div class="answer-section">
                    <div class="reason-wrapper">
                        <label class="reason-label">
                            ${attempts > 0 && !canRetryQuestion ? 
                                'Your explanation (required for retry):' : 
                                'Explain your reasoning (optional but enables retry):'}
                        </label>
                        <textarea 
                            id="reason-${question.id}"
                            class="reason-textarea ${attempts > 0 && canRetryQuestion ? 'required' : ''}"
                            placeholder="${attempts > 0 && !canRetryQuestion ? 
                                'Previous attempt did not include reasoning. Add reasoning to enable retry.' : 
                                'Explain why you chose this answer...'}"
                            ${!canRetryQuestion && attempts >= 3 ? 'disabled' : ''}
                        >${classData.users[currentUsername]?.reasons?.[question.id] || ''}</textarea>
                    </div>
                    <div>
                        <button 
                            id="submit-${question.id}"
                            class="submit-button" 
                            onclick="submitAnswer('${question.id}', '${question.type}')"
                            ${!canRetryQuestion && isAnswered ? 'disabled' : ''}
                        >
                            ${isAnswered ? (canRetryQuestion ? 'Update Answer' : 'Max Attempts Reached') : 'Submit Answer'}
                        </button>
                        <span id="error-${question.id}" class="error-msg"></span>
                        <span id="success-${question.id}" class="success-msg"></span>
                    </div>
                </div>
            `;

            // Add dotplot section (always visible if answered)
            if (isAnswered) {
                html += `
                    <div class="dotplot-section show" id="dotplot-section-${question.id}">
                        <canvas id="dotplot-${question.id}" width="400" height="200"></canvas>
                        <div id="consensus-${question.id}"></div>
                        <div class="contributors-list" id="contributors-${question.id}"></div>
                    </div>
                `;
            } else {
                html += `<div class="dotplot-section" id="dotplot-section-${question.id}"></div>`;
            }

            html += '</div>';
            return html;
        }

        // Render attachments (charts, tables, images)
        function renderAttachments(attachments, questionId) {
            let html = '';
            
            // Handle charts
            if (attachments.chartType) {
                html += renderChart(attachments, questionId);
            }
            
            // Handle tables
            if (attachments.table) {
                html += renderTable(attachments.table);
            }
            
            // Handle images
            if (attachments.image) {
                html += `
                    <div class="image-container">
                        <img src="${attachments.image}" alt="Question image" style="max-width: 100%; height: auto;">
                    </div>
                `;
            }
            
            return html;
        }
        
        // Render chart placeholder (actual rendering happens later)
        function renderChart(chartData, questionId) {
              const chartId = `chart-${questionId}`;
              const config = chartData.chartConfig || {};

              // Use the chart's title if available, otherwise use the chart type
              const chartTitle = chartData.title ?
                  chartData.title :
                  (config.description ?
                      `📊 ${chartData.chartType.toUpperCase()} CHART` :
                      `📊 ${chartData.chartType.toUpperCase()} CHART`);

              // Allow a chart to request full horizontal space when rendered inside a "multiple-charts-container"
              const containerStyle = chartData.fullWidth ? 'style="flex:0 0 100%; max-width:100%; width:100%;"' : '';

              let chartHtml = `
                  <div class="chart-container" ${containerStyle}>
                      <div class="chart-title">${chartTitle}</div>
                      ${config.description ? `<div style="font-size: 0.9em; color: #666; text-align: center; margin-bottom: 10px; font-style: italic;">${config.description}</div>` : 
  ''}
                      <div class="chart-canvas">
                          <canvas id="${chartId}"></canvas>
                      </div>
                  </div>
              `;

              // Return HTML first, then we'll create the chart after the DOM is updated
              setTimeout(() => {
                  const canvas = document.getElementById(chartId);
                  if (!canvas) return;

                  const ctx = canvas.getContext('2d');

                  if (chartData.chartType === 'bar' || chartData.chartType === 'histogram') {
                      // Ensure every segment in a stacked / segmented bar gets its own visually distinct color
                      // 1. Compute one shared palette sized to the total number of series.
                      // 2. Pick the palette entry matching the series index (wrap-around safety for very large N).
                      const colorPalette = generateChartColors(chartData.series.length);

                      const datasets = chartData.series.map((series, index) => {
                          const color = colorPalette[index % colorPalette.length] || '#36A2EB';
                          return {
                              label: series.name,
                              data: series.values,
                              backgroundColor: color,
                              borderColor: color,
                              borderWidth: 1
                          };
                      });

                      // Use chartConfig if available, otherwise use defaults
                      const yAxisConfig = config.yAxis || {};
                      const xAxisConfig = config.xAxis || {};

                      // Handle grid lines - support both old and new formats
                      let showHorizontalGrid = true;
                      let showVerticalGrid = false;

                      if (config.gridLines !== undefined) {
                          if (typeof config.gridLines === 'boolean') {
                              // Old format: gridLines: true/false
                              showHorizontalGrid = config.gridLines;
                              showVerticalGrid = false;
                          } else if (typeof config.gridLines === 'object') {
                              // New format: gridLines: {horizontal: true, vertical: false}
                              showHorizontalGrid = config.gridLines.horizontal !== false;
                              showVerticalGrid = config.gridLines.vertical === true;
                          }
                      }

                      // Configure bar spacing - gaps for bar charts, no gaps for histograms
                      const isHistogram = chartData.chartType === 'histogram';
                      const categoryPercentage = isHistogram ? 1.0 : 0.8;
                      const barPercentage = isHistogram ? 1.0 : 0.9;

                      // NEW: Detect orientation for bar charts (default to vertical)
                      const orientation = config.orientation || 'vertical';
                      const isHorizontalBar = orientation === 'horizontal';

                      // NEW: Detect if bars should be stacked (applies only to bar charts)
                      const isStacked = config.stacked === true || config.stacked === 'true';

                      // Handle labels based on orientation - support both xLabels and yLabels
                      let displayLabels = isHorizontalBar ? (chartData.yLabels || chartData.xLabels) : (chartData.xLabels || chartData.yLabels);

                      // Preserve existing labelType overrides
                      if (xAxisConfig.labelType === 'upperBound' && xAxisConfig.labels) {
                          displayLabels = xAxisConfig.labels;
                      } else if (xAxisConfig.labelType === 'range' && chartData.xLabels) {
                          displayLabels = chartData.xLabels;
                      } else if (xAxisConfig.labelType === 'lowerBound') {
                          displayLabels = xAxisConfig.labels || chartData.xLabels;
                      }

                      const chart = new Chart(ctx, {
                          type: 'bar',
                          data: {
                              labels: displayLabels,
                              datasets: datasets
                          },
                          options: {
                              indexAxis: isHorizontalBar ? 'y' : 'x',
                              responsive: true,
                              maintainAspectRatio: false,
                              categoryPercentage: categoryPercentage,
                              barPercentage: barPercentage,
                              scales: isHorizontalBar ? {
                                  x: {
                                      beginAtZero: xAxisConfig.min !== undefined ? (xAxisConfig.min === 0) : true,
                                      min: xAxisConfig.min,
                                      max: xAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      stacked: isStacked,
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          maxTicksLimit: xAxisConfig.tickInterval ? undefined : 10,
                                          precision: 2,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (xAxisConfig.tickInterval) {
                                                  const step = xAxisConfig.tickInterval;
                                                  const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  y: {
                                      title: {
                                          display: true,
                                          text: yAxisConfig.title || 'Category',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          color: getTextColor()
                                      },
                                      offset: true
                                  }
                              } : {
                                  y: {
                                      beginAtZero: yAxisConfig.min !== undefined ? (yAxisConfig.min === 0) : true,
                                      min: yAxisConfig.min,
                                      max: yAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: yAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor(),
                                          lineWidth: 1,
                                          drawBorder: true,
                                          drawOnChartArea: true,
                                          drawTicks: !yAxisConfig.hideTicks
                                      },
                                      stacked: isStacked,
                                      ticks: {
                                          stepSize: yAxisConfig.tickInterval,
                                          maxTicksLimit: yAxisConfig.tickInterval ? undefined : 10,
                                          precision: 2,
                                          color: getTextColor(),
                                          display: !yAxisConfig.hideTicks,
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              if (yAxisConfig.hideTicks) return '';
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (yAxisConfig.tickInterval) {
                                                  const step = yAxisConfig.tickInterval;
                                                  const min = yAxisConfig.min !== undefined ? yAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  x: {
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Category',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      stacked: isStacked,
                                      ticks: {
                                          color: getTextColor()
                                      },
                                      offset: true
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: datasets.length > 1,
                                      labels: {
                                          color: getTextColor()
                                      }
                                  },
                                  // Enable data labels for bar/histogram charts when requested via chartConfig.showPointLabels
                                  datalabels: {
                                      display: config.showPointLabels === true,
                                      color: getTextColor(),
                                      anchor: isHorizontalBar ? 'center' : 'end',
                                      align: isHorizontalBar ? 'right' : 'top',
                                      formatter: (value) => value
                                  }
                              }
                          }
                      });
                      chartInstances[chartId] = chart;

                  } else if (chartData.chartType === 'pie') {
                      const seriesData = chartData.series[0].values;
                      const labels = seriesData.map(item => item.name);
                      const values = seriesData.map(item => item.value);

                      const chart = new Chart(ctx, {
                          type: 'pie',
                          data: {
                              labels: labels,
                              datasets: [{
                                  data: values,
                                  backgroundColor: generateChartColors(values.length),
                                  borderWidth: 2,
                                  borderColor: isDarkMode() ? '#2d2d2d' : '#fff'
                              }]
                          },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              plugins: {
                                  legend: {
                                      position: 'bottom',
                                      labels: {
                                          padding: 20,
                                          usePointStyle: true,
                                          color: getTextColor()
                                      }
                                  },
                                  // Optional data labels for pie charts (percentages) when chartConfig.showPointLabels is true
                                  datalabels: {
                                      display: (config.showPointLabels === true),
                                      color: getTextColor(),
                                      formatter: function(value, context) {
                                          const total = values.reduce((a, b) => a + b, 0);
                                          const percentage = ((value / total) * 100).toFixed(1);
                                          return percentage + '%';
                                      }
                                  },
                                  tooltip: {
                                      callbacks: {
                                          label: function(context) {
                                              const total = values.reduce((a, b) => a + b, 0);
                                              const percentage = ((context.parsed / total) * 100).toFixed(1);
                                              return `${context.label}: ${context.parsed} (${percentage}%)`;
                                          }
                                      }
                                  }
                              }
                          }
                      });
                      chartInstances[chartId] = chart;

                  } else if (chartData.chartType === 'scatter') {
                      const config = chartData.chartConfig || {};
                      const xAxisConfig = config.xAxis || {};
                      const yAxisConfig = config.yAxis || {};

                      // Handle grid lines - support both old and new formats
                      let showHorizontalGrid = true;
                      let showVerticalGrid = true; // Scatter plots often show both grids

                      if (config.gridLines !== undefined) {
                          if (typeof config.gridLines === 'boolean') {
                              // Old format: gridLines: true/false
                              showHorizontalGrid = config.gridLines;
                              showVerticalGrid = config.gridLines;
                          } else if (typeof config.gridLines === 'object') {
                              // New format: gridLines: {horizontal: true, vertical: false}
                              showHorizontalGrid = config.gridLines.horizontal === true;
                              showVerticalGrid = config.gridLines.vertical === true;
                          }
                      }

                      // Build primary dataset (scatter points)
                      const datasets = [{
                          label: 'Data Points',
                          data: chartData.points,
                          backgroundColor: getScatterPointColor(),
                          borderColor: getScatterPointColor(),
                          pointRadius: 4,
                          pointHoverRadius: 6
                      }];

                      // Determine if we should render point labels
                      const hasPointLabels = (chartData.points || []).some(pt => pt.label !== undefined);

                      // --------------------------------------------------
                      // Optional regression line (least-squares)            <-- ADD
                      // --------------------------------------------------
                      if (config.regressionLine) {
                          const pts = chartData.points || [];
                          if (Array.isArray(pts) && pts.length >= 2) {
                              // Compute least-squares slope and intercept
                              let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
                              pts.forEach(p => {
                                  sumX += p.x;
                                  sumY += p.y;
                                  sumXY += p.x * p.y;
                                  sumXX += p.x * p.x;
                              });
                              const n = pts.length;
                              const denominator = n * sumXX - sumX * sumX;
                              if (denominator !== 0) {
                                  const slope = (n * sumXY - sumX * sumY) / denominator;
                                  const intercept = (sumY - slope * sumX) / n;

                                  // Determine the horizontal span for the line
                                  let minX = typeof xAxisConfig.min === 'number' ? xAxisConfig.min : undefined;
                                  let maxX = typeof xAxisConfig.max === 'number' ? xAxisConfig.max : undefined;
                                  if (minX === undefined || maxX === undefined) {
                                      const xs = pts.map(p => p.x);
                                      if (minX === undefined) minX = Math.min(...xs);
                                      if (maxX === undefined) maxX = Math.max(...xs);
                                  }

                                  // Style overrides (optional)
                                  const regColor = config.regressionLineColor || getTextColor();
                                  const regDash  = config.regressionLineDash  || [];

                                  datasets.push({
                                      label: 'Regression Line',
                                      type: 'line',
                                      data: [
                                          { x: minX, y: slope * minX + intercept },
                                          { x: maxX, y: slope * maxX + intercept }
                                      ],
                                      borderColor: regColor,
                                      borderDash: regDash,
                                      borderWidth: 2,
                                      fill: false,
                                      pointRadius: 0,
                                      tension: 0,
                                      order: 0
                                  });
                              }
                          }
                      }

                      // --------------------------------------------------
                      // Optional reference line at y = 0 (useful for residual plots)
                      // --------------------------------------------------
                      if (config.referenceLineAtZero) {
                          // Determine horizontal span of the scatter data (fallback to axis min/max)
                          let minX = typeof xAxisConfig.min === 'number' ? xAxisConfig.min : undefined;
                          let maxX = typeof xAxisConfig.max === 'number' ? xAxisConfig.max : undefined;
                          if (minX === undefined || maxX === undefined) {
                              const xs = chartData.points.map(p => p.x);
                              if (minX === undefined) minX = Math.min(...xs);
                              if (maxX === undefined) maxX = Math.max(...xs);
                          }

                          datasets.push({
                              label: 'Reference Line y = 0',
                              type: 'line',
                              data: [
                                  { x: minX, y: 0 },
                                  { x: maxX, y: 0 }
                              ],
                              borderColor: '#CC0000',
                              borderDash: [6, 4],
                              borderWidth: 2,
                              fill: false,
                              pointRadius: 0,
                              order: 0
                          });
                      }

                      const chart = new Chart(ctx, {
                          type: 'scatter',
                          data: {
                              datasets: datasets
                          },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xAxisConfig.min,
                                      max: xAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'X Variable',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (xAxisConfig.tickInterval) {
                                                  const step = xAxisConfig.tickInterval;
                                                  const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  y: {
                                      min: yAxisConfig.min,
                                      max: yAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: yAxisConfig.title || 'Y Variable',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          stepSize: yAxisConfig.tickInterval,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (yAxisConfig.tickInterval) {
                                                  const step = yAxisConfig.tickInterval;
                                                  const min = yAxisConfig.min !== undefined ? yAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: false
                                  },
                                  datalabels: {
                                      display: (ctx) => {
                                          const d = ctx.dataset.data[ctx.dataIndex];
                                          // Show label if point has 'label' or global chartConfig requests labels
                                          return (d && d.label !== undefined) || config.showPointLabels === true;
                                      },
                                      align: 'top',
                                      anchor: 'center',
                                      color: getTextColor(),
                                      formatter: (value) => {
                                          // If value has explicit label use that, otherwise display y
                                          if (value.label !== undefined) return value.label;
                                          if (config.showPointLabels === true) {
                                              return `(${value.x}, ${value.y})`;
                                          }
                                          return '';
                                      },
                                      font: {
                                          size: 12
                                      }
                                  }
                              }
                          }
                      });
                      chartInstances[chartId] = chart;

                      // Add point label plugin AFTER chart creation to ensure meta is available
                      if (false && (hasPointLabels || config.showPointLabels)) {
                          // Create inline plugin specific to this chart instance
                          const labelPlugin = {
                              id: 'scatterPointLabels',
                              afterDatasetsDraw: (c) => {
                                  if (c !== chart) return; // Only draw for this chart instance
                                  const ctx = c.ctx;
                                  ctx.save();
                                  c.data.datasets.forEach((ds, dsi) => {
                                      // Only annotate the point dataset (assumed first) or explicitly marked datasets
                                      if (dsi !== 0) return;
                                      const meta = c.getDatasetMeta(dsi);
                                      meta.data.forEach((elem, idx) => {
                                          const pointData = ds.data[idx];
                                          const lbl = pointData && pointData.label;
                                          if (lbl === undefined) return;
                                          const {x, y} = elem.getCenterPoint();
                                          ctx.fillStyle = getTextColor();
                                          ctx.font = '12px sans-serif';
                                          ctx.textAlign = 'center';
                                          ctx.textBaseline = 'bottom';
                                          ctx.fillText(lbl, x, y - 6);
                                      });
                                  });
                                  ctx.restore();
                              }
                          };
                          chart.options.plugins = chart.options.plugins || [];
                          chart.options.plugins.push(labelPlugin);
                          chart.update();
                      }

                  } else if (chartData.chartType === 'dotplot') {
                      const config = chartData.chartConfig || {};
                      const xAxisConfig = config.xAxis || {};

                      // Handle grid lines - dotplots typically have no grid lines
                      let showHorizontalGrid = false;
                      let showVerticalGrid = false;

                      if (config.gridLines !== undefined) {
                          if (typeof config.gridLines === 'boolean') {
                              showHorizontalGrid = config.gridLines;
                              showVerticalGrid = config.gridLines;
                          } else if (typeof config.gridLines === 'object') {
                              showHorizontalGrid = config.gridLines.horizontal === true;
                              showVerticalGrid = config.gridLines.vertical === true;
                          }
                      }

                      // Convert raw values to frequency data for dotplot
                      const valueFrequency = {};
                      chartData.values.forEach(value => {
                          valueFrequency[value] = (valueFrequency[value] || 0) + 1;
                      });

                      // Create stacked dots data
                      const dotplotData = [];
                      for (const [value, frequency] of Object.entries(valueFrequency)) {
                          for (let i = 1; i <= frequency; i++) {
                              dotplotData.push({
                                  x: parseFloat(value),
                                  y: i
                              });
                          }
                      }

                      // Find max frequency for y-axis
                      const maxFrequency = Math.max(...Object.values(valueFrequency));

                      // Allow caller to set dot radius (default 4)
                      const dotRadius = (config.dotRadius !== undefined ? config.dotRadius : 4);

                      const chart = new Chart(ctx, {
                          type: 'scatter',
                          data: {
                              datasets: [{
                                  label: 'Data Points',
                                  data: dotplotData,
                                  backgroundColor: getScatterPointColor(),
                                  borderColor: getScatterPointColor(),
                                  pointRadius: dotRadius,
                                  pointHoverRadius: dotRadius + 2,
                                  showLine: false
                              }]
                          },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xAxisConfig.min,
                                      max: xAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (xAxisConfig.tickInterval) {
                                                  const step = xAxisConfig.tickInterval;
                                                  const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  y: {
                                      type: 'linear',
                                      min: 0,
                                      max: maxFrequency + 1,
                                      title: {
                                          display: false  // Dotplots don't typically show y-axis labels
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          display: false,  // Hide y-axis tick labels
                                          stepSize: 1
                                      }
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: false
                                  },
                                  datalabels: {
                                      display: () => config.showPointLabels === true,
                                      align: 'top',
                                      anchor: 'center',
                                      color: getTextColor(),
                                      formatter: (value) => value.y,
                                      font: { size: 12 }
                                  },
                                  tooltip: {
                                      callbacks: {
                                          title: function(context) {
                                              return `Value: ${context[0].parsed.x}`;
                                          },
                                          label: function(context) {
                                              return `Count: ${valueFrequency[context.parsed.x]}`;
                                          }
                                      }
                                  }
                              }
                          }
                      });
                       chartInstances[chartId] = chart;

                      // Adjust chart height so stacked dots appear closer (rough heuristic)
                      const minHeight = 120;
                      const desiredHeight = Math.max(minHeight, (dotRadius * 2 + 4) * (maxFrequency + 1));
                      canvas.parentElement.style.height = desiredHeight + 'px';


                  } else if (chartData.chartType === 'boxplot') {
                      const config = chartData.chartConfig || {};
                      const xAxisConfig = config.xAxis || {};
                      const boxplotData = config.boxplotData || {};

                      // Handle grid lines
                      let showHorizontalGrid = false;
                      let showVerticalGrid = false;

                      if (config.gridLines !== undefined) {
                          if (typeof config.gridLines === 'boolean') {
                              showHorizontalGrid = config.gridLines;
                              showVerticalGrid = config.gridLines;
                          } else if (typeof config.gridLines === 'object') {
                              showHorizontalGrid = config.gridLines.horizontal === true;
                              showVerticalGrid = config.gridLines.vertical === true;
                          }
                      }

                      // Handle multiple boxplots (array) or single boxplot (object)
                      const boxplots = Array.isArray(boxplotData) ? boxplotData : [boxplotData];

                      // Check orientation from config (default to horizontal)
                      const orientation = config.orientation || 'horizontal';
                      const isHorizontal = orientation === 'horizontal';

                      // Find overall min/max for axis scaling
                      let overallMin = Infinity;
                      let overallMax = -Infinity;

                      boxplots.forEach(boxplot => {
                          const { Q1, Q3, median, min, max, whiskerMin, whiskerMax, outliers } = boxplot;

                          // Support both old format (min/max) and new format (whiskerMin/whiskerMax + outliers)
                          const actualWhiskerMin = whiskerMin !== undefined ? whiskerMin : min;
                          const actualWhiskerMax = whiskerMax !== undefined ? whiskerMax : max;
                          const actualOutliers = outliers || [];

                          // Calculate overall range including outliers
                          const allValues = [actualWhiskerMin, actualWhiskerMax, ...actualOutliers];
                          overallMin = Math.min(overallMin, Math.min(...allValues));
                          overallMax = Math.max(overallMax, Math.max(...allValues));
                                           });

                      // Create boxplot visualization with orientation support
                      let datasets = [];

                      // Generate colors for multiple boxplots
                      const boxplotColors = generateChartColors(boxplots.length);

                      boxplots.forEach((boxplot, index) => {
                          const { Q1, Q3, median, min, max, whiskerMin, whiskerMax, outliers, name } = boxplot;

                          // Support both old format (min/max) and new format (whiskerMin/whiskerMax + outliers)
                          const actualWhiskerMin = whiskerMin !== undefined ? whiskerMin : min;
                          const actualWhiskerMax = whiskerMax !== undefined ? whiskerMax : max;
                          const actualOutliers = outliers || [];

                          // Calculate position for multiple boxplots
                          const boxplotSpacing = 0.8; // Space between boxplots
                          const yPos = isHorizontal ? (index - (boxplots.length - 1) / 2) * boxplotSpacing : 0;
                          const xPos = !isHorizontal ? (index - (boxplots.length - 1) / 2) * boxplotSpacing : 0;

                          const color = boxplotColors[index];
                          const boxplotName = name || `Boxplot ${index + 1}`;

                          if (isHorizontal) {
                              // Horizontal boxplot
                              datasets.push(
                                  // Median line (vertical in horizontal boxplot)
                                  {
                                      label: `${boxplotName} Median`,
                                      data: [{ x: median, y: yPos - 0.2 }, { x: median, y: yPos + 0.2 }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 3,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Lower whisker (horizontal)
                                  {
                                      label: `${boxplotName} Lower Whisker`,
                                      data: [{ x: actualWhiskerMin, y: yPos }, { x: Q1, y: yPos }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Upper whisker (horizontal)
                                  {
                                      label: `${boxplotName} Upper Whisker`,
                                      data: [{ x: Q3, y: yPos }, { x: actualWhiskerMax, y: yPos }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Whisker caps (vertical)
                                  {
                                      label: `${boxplotName} Lower Cap`,
                                      data: [
                                          { x: actualWhiskerMin, y: yPos - 0.1 },
                                          { x: actualWhiskerMin, y: yPos + 0.1 }
                                      ],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  {
                                      label: `${boxplotName} Upper Cap`,
                                      data: [
                                          { x: actualWhiskerMax, y: yPos - 0.1 },
                                          { x: actualWhiskerMax, y: yPos + 0.1 }
                                      ],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  }
                              );

                              // Add outliers if any
                              if (actualOutliers.length > 0) {
                                  const outlierData = actualOutliers.map(outlierValue => ({ x: outlierValue, y: yPos }));
                                  datasets.push({
                                      label: `${boxplotName} Outliers`,
                                      data: outlierData,
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 5,
                                      showLine: false,
                                      type: 'scatter'
                                  });
                              }
                          } else {
                              // Vertical boxplot
                              datasets.push(
                                  // Median line (horizontal in vertical boxplot)
                                  {
                                      label: `${boxplotName} Median`,
                                      data: [{ x: xPos - 0.2, y: median }, { x: xPos + 0.2, y: median }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 3,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Lower whisker (vertical)
                                  {
                                      label: `${boxplotName} Lower Whisker`,
                                      data: [{ x: xPos, y: actualWhiskerMin }, { x: xPos, y: Q1 }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Upper whisker (vertical)
                                  {
                                      label: `${boxplotName} Upper Whisker`,
                                      data: [{ x: xPos, y: Q3 }, { x: xPos, y: actualWhiskerMax }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Whisker caps (horizontal)
                                  {
                                      label: `${boxplotName} Lower Cap`,
                                      data: [
                                          { x: xPos - 0.1, y: actualWhiskerMin },
                                          { x: xPos + 0.1, y: actualWhiskerMin }
                                      ],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  {
                                      label: `${boxplotName} Upper Cap`,
                                      data: [
                                          { x: xPos - 0.1, y: actualWhiskerMax },
                                          { x: xPos + 0.1, y: actualWhiskerMax }
                                      ],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  }
                              );

                              // Add outliers if any
                              if (actualOutliers.length > 0) {
                                  const outlierData = actualOutliers.map(outlierValue => ({ x: xPos, y: outlierValue }));
                                  datasets.push({
                                      label: `${boxplotName} Outliers`,
                                      data: outlierData,
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 5,
                                      showLine: false,
                                      type: 'scatter'
                                  });
                              }
                          }
                      }); // End of boxplots.forEach

                      // High DPI canvas resize for crisp rendering
                      const dpr = window.devicePixelRatio || 1;
                      const parentRect = canvas.parentElement.getBoundingClientRect();
                      const displayWidth = parentRect.width;
                      const displayHeight = parentRect.height;
                      canvas.width = displayWidth * dpr;
                      canvas.height = displayHeight * dpr;
                      canvas.style.width = displayWidth + 'px';
                      canvas.style.height = displayHeight + 'px';
                      // Do NOT manually scale ctx – Chart.js handles DPR internally

                      const chart = new Chart(ctx, {
                          type: 'scatter',
                          data: {
                              datasets: datasets
                          },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: isHorizontal ? {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xAxisConfig.min || (overallMin - 2),
                                      max: xAxisConfig.max || (overallMax + 2),
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (xAxisConfig.tickInterval) {
                                                  const step = xAxisConfig.tickInterval;
                                                  const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  y: {
                                      type: 'linear',
                                      min: -(boxplots.length) * 0.5,
                                      max: (boxplots.length) * 0.5,
                                      display: boxplots.length > 1,  // Show y-axis labels for multiple boxplots
                                      title: {
                                          display: boxplots.length > 1,
                                          text: 'Groups',
                                          color: getTextColor()
                                      },
                                      ticks: {
                                          display: boxplots.length > 1,
                                          color: getTextColor(),
                                          callback: function(value, index) {
                                              const boxplotIndex = Math.round(value + (boxplots.length - 1) / 2);
                                              if (boxplotIndex >= 0 && boxplotIndex < boxplots.length) {
                                                  return boxplots[boxplotIndex].name || `Group ${boxplotIndex + 1}`;
                                              }
                                              return '';
                                          }
                                      }
                                  }
                              } : {
                                  x: {
                                      type: 'linear',
                                      min: -(boxplots.length) * 0.5,
                                      max: (boxplots.length) * 0.5,
                                      display: boxplots.length > 1,  // Show x-axis labels for multiple boxplots
                                      title: {
                                          display: boxplots.length > 1,
                                          text: 'Groups',
                                          color: getTextColor()
                                      },
                                      ticks: {
                                          display: boxplots.length > 1,
                                          color: getTextColor(),
                                          callback: function(value, index) {
                                              const boxplotIndex = Math.round(value + (boxplots.length - 1) / 2);
                                              if (boxplotIndex >= 0 && boxplotIndex < boxplots.length) {
                                                  return boxplots[boxplotIndex].name || `Group ${boxplotIndex + 1}`;
                                              }
                                              return '';
                                          }
                                      }
                                  },
                                  y: {
                                      type: 'linear',
                                      position: 'left',
                                      min: xAxisConfig.min || (overallMin - 2),
                                      max: xAxisConfig.max || (overallMax + 2),
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          display: !config.yAxis || !config.yAxis.hideTicks,
                                          stepSize: config.yAxis && config.yAxis.tickInterval,
                                          color: getTextColor()
                                      }
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: false
                                  },
                                  tooltip: {
                                      callbacks: {
                                          title: function(context) {
                                              const dataset = context[0].dataset;
                                              return dataset.label;
                                          },
                                          label: function(context) {
                                              const dataset = context.dataset;

                                              if (dataset.label.includes('Median')) {
                                                  const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                                  return `Median: ${value}`;
                                              } else if (dataset.label.includes('Outliers')) {
                                                  const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                                  return `Outlier: ${value}`;
                                              } else if (dataset.label.includes('Whisker')) {
                                                  const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                                  return `Whisker endpoint: ${value}`;
                                              } else if (dataset.label.includes('Cap')) {
                                                  const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                                  return `Whisker cap: ${value}`;
                                              }
                                              const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                              return `Value: ${value}`;
                                          }
                                      }
                                  },
                                  datalabels: {
                                      display: (ctx) => {
                                          const cfg = (chartData.chartConfig || {});
                                          return cfg.showPointLabels === true; // off by default
                                      },
                                      color: getTextColor(),
                                      align: 'top',
                                      anchor: 'center'
                                  }
                              }
                          },
                          plugins: [{
                              id: 'boxplotBox',
                              afterDraw: function(chart) {
                                  const ctx = chart.ctx;
                                  const chartArea = chart.chartArea;
                                  ctx.save();

                                  // Draw boxes for each boxplot
                                  const boxplotSpacing = 0.8; // Space between boxplots
                                  boxplots.forEach((boxplot, index) => {
                                      const { Q1, Q3, name } = boxplot;
                                      const color = boxplotColors[index];

                                      // Set fill and stroke styles
                                      ctx.fillStyle = color + '33'; // Add transparency
                                      ctx.strokeStyle = color;
                                      ctx.lineWidth = 2;

                                      if (isHorizontal) {
                                          const xScale = chart.scales.x;
                                          const yScale = chart.scales.y;
                                          const boxHeight = 30;
                                          const yPos = (index - (boxplots.length - 1) / 2) * boxplotSpacing;
                                          const centerY = yScale.getPixelForValue(yPos);
                                          const q1X = xScale.getPixelForValue(Q1);
                                          const q3X = xScale.getPixelForValue(Q3);
                                          ctx.fillRect(q1X, centerY - boxHeight/2, q3X - q1X, boxHeight);
                                          ctx.strokeRect(q1X, centerY - boxHeight/2, q3X - q1X, boxHeight);
                                      } else {
                                          const xScale = chart.scales.x;
                                          const yScale = chart.scales.y;
                                          const boxWidth = 30;
                                          const xPos = (index - (boxplots.length - 1) / 2) * boxplotSpacing;
                                          const centerX = xScale.getPixelForValue(xPos);
                                          const q1Y = yScale.getPixelForValue(Q1);
                                          const q3Y = yScale.getPixelForValue(Q3);
                                          ctx.fillRect(centerX - boxWidth/2, q3Y, boxWidth, q1Y - q3Y);
                                          ctx.strokeRect(centerX - boxWidth/2, q3Y, boxWidth, q1Y - q3Y);
                                      }
                                  });

                                  ctx.restore();
                              }
                          }]
                      });
                      chartInstances[chartId] = chart;
                  } else if (chartData.chartType === 'normal') {
                      // --------------------------------------------------
                      // Normal distribution curve with optional shaded region
                      // --------------------------------------------------
                      const mean = (typeof chartData.mean === 'number') ? chartData.mean : 0;
                      const sd   = (typeof chartData.sd   === 'number' && chartData.sd > 0) ? chartData.sd : 1;
                      const shade = chartData.shade || null; // {lower: number|null, upper: number|null}

                      const config        = chartData.chartConfig || {};
                      const xAxisConfig   = config.xAxis || {};
                      const yAxisConfig   = config.yAxis || {};

                      const xMin = (typeof xAxisConfig.min === 'number') ? xAxisConfig.min : mean - 3 * sd;
                      const xMax = (typeof xAxisConfig.max === 'number') ? xAxisConfig.max : mean + 3 * sd;
                      const tickInterval = (typeof xAxisConfig.tickInterval === 'number') ? xAxisConfig.tickInterval : sd;

                      const pdf = (x) => (1 / (sd * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mean) / sd, 2));

                      const numPoints = 120;
                      const curvePoints = [];
                      const shadePoints = [];

                      const peakY = pdf(mean);

                      for (let i = 0; i <= numPoints; i++) {
                          const x = xMin + (i / numPoints) * (xMax - xMin);
                          const rawY = pdf(x);
                          const y = rawY / peakY; // scale
                          curvePoints.push({ x, y });

                          if (shade) {
                              const inLower = (shade.lower == null) || (x >= shade.lower);
                              const inUpper = (shade.upper == null) || (x <= shade.upper);
                              shadePoints.push({ x, y: (inLower && inUpper) ? y : null });
                          }
                      }

                      const datasets = [{
                          label: 'Normal Curve',
                          type: 'line',
                          data: curvePoints,
                          borderColor: getTextColor(),
                          borderWidth: 2,
                          fill: false,
                          pointRadius: 0,
                          tension: 0.15
                      }];

                      if (shade) {
                          const shadeColor = isDarkMode() ? 'rgba(200,200,200,0.35)' : 'rgba(0,0,0,0.25)';
                          datasets.push({
                              label: 'Shaded Region',
                              type: 'line',
                              data: shadePoints,
                              borderColor: 'transparent',
                              backgroundColor: shadeColor,
                              fill: 'origin',
                              pointRadius: 0,
                              tension: 0.15,
                              borderWidth: 0
                          });
                      }

                      const chart = new Chart(ctx, {
                          type: 'line',
                          data: { datasets },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xMin,
                                      max: xMax,
                                      ticks: {
                                          stepSize: tickInterval,
                                          color: getTextColor()
                                      },
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: { display: false }
                                  },
                                  y: {
                                      beginAtZero: true,
                                      display: false,
                                      min: 0,
                                      title: {
                                          display: !!yAxisConfig.title,
                                          text: yAxisConfig.title || '',
                                          color: getTextColor()
                                      },
                                      grid: { display: false },
                                      ticks: { display: false }
                                  }
                              },
                              plugins: { legend: { display: false }, datalabels: { display: false } }
                          }
                      });
                      chartInstances[chartId] = chart;
                  } else if (chartData.chartType === 'chisquare') {
                      // --- New chi-square distribution rendering ---
                      const cfg = chartData.chartConfig || {};
                      const xAxisConfig = cfg.xAxis || {};
                      const yAxisConfig = cfg.yAxis || {};

                      // Accept list of degrees of freedom or single df
                      const dfList = Array.isArray(chartData.dfList) && chartData.dfList.length > 0 ?
                                      chartData.dfList :
                                      (typeof chartData.df === 'number' ? [chartData.df] : [1]);

                      // Optional labels array; default to "df = k" notation
                      const labels = Array.isArray(chartData.labels) && chartData.labels.length === dfList.length ?
                                      chartData.labels : dfList.map(df => `df = ${df}`);

                      const xMin = typeof xAxisConfig.min === 'number' ? xAxisConfig.min : 0;
                      const xMax = typeof xAxisConfig.max === 'number' ? xAxisConfig.max : Math.max(...dfList) * 3.5;
                      const numPoints = cfg.numPoints || 120;

                      // Lightweight Lanczos approximation for Gamma function
                      function gamma(z) {
                          const p = [
                              0.99999999999980993,
                              676.5203681218851,
                              -1259.1392167224028,
                              771.32342877765313,
                              -176.61502916214059,
                              12.507343278686905,
                              -0.13857109526572012,
                              9.9843695780195716e-6,
                              1.5056327351493116e-7
                          ];
                          const g = 7;
                          if (z < 0.5) {
                              return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
                          }
                          z -= 1;
                          let x = p[0];
                          for (let i = 1; i < p.length; i++) {
                              x += p[i] / (z + i);
                          }
                          const t = z + g + 0.5;
                          return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
                      }

                      // Chi-square probability density function
                      function chiSquarePdf(x, k) {
                          if (x <= 0) return 0;
                          const coeff = 1 / (Math.pow(2, k / 2) * gamma(k / 2));
                          return coeff * Math.pow(x, k / 2 - 1) * Math.exp(-x / 2);
                      }

                      const colorPalette = generateChartColors(dfList.length);
                      const datasets = dfList.map((df, idx) => {
                          const pts = [];
                          for (let i = 0; i <= numPoints; i++) {
                              const xVal = xMin + (i / numPoints) * (xMax - xMin);
                              pts.push({ x: xVal, y: chiSquarePdf(xVal, df) });
                          }
                          const color = colorPalette[idx % colorPalette.length] || '#36A2EB';
                          return {
                              label: labels[idx],
                              type: 'line',
                              data: pts,
                              borderColor: color,
                              borderWidth: 2,
                              fill: false,
                              pointRadius: 0,
                              tension: 0.15
                          };
                      });

                      // Grid line settings (reuse existing pattern)
                      let showHorizontalGrid = true;
                      let showVerticalGrid = false;
                      if (cfg.gridLines !== undefined) {
                          if (typeof cfg.gridLines === 'boolean') {
                              showHorizontalGrid = cfg.gridLines;
                          } else if (typeof cfg.gridLines === 'object') {
                              showHorizontalGrid = cfg.gridLines.horizontal !== false;
                              showVerticalGrid = cfg.gridLines.vertical === true;
                          }
                      }

                      const chart = new Chart(ctx, {
                          type: 'line',
                          data: { datasets },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xMin,
                                      max: xMax,
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'χ²',
                                          color: getTextColor()
                                      },
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      }
                                  },
                                  y: {
                                      beginAtZero: true,
                                      title: {
                                          display: !!yAxisConfig.title,
                                          text: yAxisConfig.title || '',
                                          color: getTextColor()
                                      },
                                      ticks: {
                                          display: yAxisConfig.hideTicks !== true,
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      }
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: dfList.length > 1,
                                      labels: { color: getTextColor() }
                                  },
                                  datalabels: {
                                      display: cfg.showPointLabels === true,
                                      color: getTextColor()
                                  }
                              }
                          }
                      });
                      chartInstances[chartId] = chart;
                  } else if (chartData.chartType === 'numberline') {
                      // --------------------------------------------------
                      // Custom number line (baseline with ticks & labels)
                      // --------------------------------------------------
                      const ticksData = Array.isArray(chartData.ticks) && chartData.ticks.length > 0 ? chartData.ticks : [
                          { x: -2, label: 'a' },
                          { x: -1, label: 'b' },
                          { x:  0, label: 'c' },
                          { x:  1, label: 'd' },
                          { x:  2, label: 'e' }
                      ];

                      // Determine horizontal span (add small margin so arrow-heads don't clip)
                      const xs = ticksData.map(t => t.x);
                      const minX = Math.min(...xs) - 0.5;
                      const maxX = Math.max(...xs) + 0.5;

                      // Build baseline dataset (straight line at y = 0)
                      const baselineDS = {
                          label: 'Number Line',
                          type: 'line',
                          data: [ { x: minX, y: 0 }, { x: maxX, y: 0 } ],
                          borderColor: getTextColor(),
                          borderWidth: 2,
                          pointRadius: 0,
                          fill: false,
                          tension: 0
                      };

                      // Inline plugin to draw ticks, labels, and arrow-heads
                      const numberLinePlugin = {
                          id: 'numberLinePlugin',
                          afterDraw: (chart) => {
                              const ctx = chart.ctx;
                              const xScale = chart.scales.x;
                              const yScale = chart.scales.y;
                              const y0 = yScale.getPixelForValue(0);

                              ctx.save();
                              ctx.strokeStyle = getTextColor();
                              ctx.fillStyle   = getTextColor();
                              ctx.lineWidth   = 2;

                              // Arrow-heads
                              const arrowSize = 6;
                              const leftPx  = xScale.getPixelForValue(minX);
                              const rightPx = xScale.getPixelForValue(maxX);

                              // Left arrow
                              ctx.beginPath();
                              ctx.moveTo(leftPx + arrowSize, y0 - arrowSize);
                              ctx.lineTo(leftPx, y0);
                              ctx.lineTo(leftPx + arrowSize, y0 + arrowSize);
                              ctx.closePath();
                              ctx.fill();

                              // Right arrow
                              ctx.beginPath();
                              ctx.moveTo(rightPx - arrowSize, y0 - arrowSize);
                              ctx.lineTo(rightPx, y0);
                              ctx.lineTo(rightPx - arrowSize, y0 + arrowSize);
                              ctx.closePath();
                              ctx.fill();

                              // Ticks & labels
                              const tickHeight = 12; // increased for visibility
                              ctx.font = '14px sans-serif';
                              ctx.textAlign = 'center';
                              ticksData.forEach(tk => {
                                  const xPx = xScale.getPixelForValue(tk.x);
                                  // Tick mark
                                  if (tk.drawTick !== false) {
                                    ctx.beginPath();
                                    ctx.moveTo(xPx, y0 - tickHeight);
                                    ctx.lineTo(xPx, y0 + tickHeight);
                                    ctx.stroke();
                                  }
                                  // Top label
                                  if (tk.label || tk.topLabel) {
                                    ctx.textBaseline = 'bottom';
                                    ctx.fillText(tk.label || tk.topLabel, xPx, y0 - tickHeight - 4);
                                  }
                                  // Bottom label
                                  if (tk.bottomLabel || tk.valueLabel) {
                                    ctx.textBaseline = 'top';
                                    ctx.fillText(tk.bottomLabel || tk.valueLabel, xPx, y0 + tickHeight + 4);
                                  }
                              });
                              ctx.restore();
                          }
                      };

                      const xAxisCfg = chartData.xAxis || {};

                      const chart = new Chart(ctx, {
                          type: 'line',
                          data: { datasets: [baselineDS] },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              animation: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      min: xAxisCfg.min !== undefined ? xAxisCfg.min : minX,
                                      max: xAxisCfg.max !== undefined ? xAxisCfg.max : maxX,
                                      ticks: {
                                          display: false
                                      },
                                      grid: { display: false },
                                      title: {
                                          display: !!xAxisCfg.title,
                                          text: xAxisCfg.title || '',
                                          color: getTextColor()
                                      }
                                  },
                                  y: {
                                      min: -1,
                                      max: 1,
                                      display: false,
                                      grid: { display: false }
                                  }
                              },
                              plugins: {
                                  legend: { display: false },
                                  datalabels: { display: false }
                              }
                          },
                          plugins: [numberLinePlugin]
                      });
                      chartInstances[chartId] = chart;
                  }
              }, 100);

              return chartHtml;
          }
          // FIXED: Table rendering to handle both object and array formats
          function renderTable(table) {
              if (!table) return '';

              let tableHtml = '<div class="table-container"><table>';

              // Handle object format (with headers and rows properties)
              if (table.headers && table.rows) {
                  // Render headers
                  tableHtml += '<thead><tr>';
                  table.headers.forEach(header => {
                      tableHtml += `<th>${header}</th>`;
                  });
                  tableHtml += '</tr></thead>';

                  // Render rows
                  if (table.rows && table.rows.length > 0) {
                      tableHtml += '<tbody>';
                      table.rows.forEach(row => {
                          tableHtml += '<tr>';
                          row.forEach(cell => {
                              tableHtml += `<td>${cell}</td>`;
                          });
                          tableHtml += '</tr>';
                      });
                      tableHtml += '</tbody>';
                  }
              }
              // Handle array format (legacy)
              else if (Array.isArray(table) && table.length > 0) {
                  const headers = table[0];
                  const rows = table.slice(1);

                  // Headers
                  tableHtml += '<thead><tr>';
                  headers.forEach(header => {
                      tableHtml += `<th>${header}</th>`;
                  });
                  tableHtml += '</tr></thead>';

                  // Rows
                  if (rows.length > 0) {
                      tableHtml += '<tbody>';
                      rows.forEach(row => {
                          tableHtml += '<tr>';
                          row.forEach(cell => {
                              tableHtml += `<td>${cell}</td>`;
                          });
                          tableHtml += '</tr>';
                      });
                      tableHtml += '</tbody>';
                  }
              }

              tableHtml += '</table></div>';

              return tableHtml;
          }
// Complete chart rendering function
function renderChartNow(chartId) {
    const canvas = document.getElementById(chartId);
    if (!canvas) return;

    // FIX: Check if chart already exists and destroy it
    if (chartInstances[chartId]) {
        chartInstances[chartId].destroy();
        delete chartInstances[chartId];
    }

    const chartData = window.pendingCharts[chartId];
    if (!chartData) return;

    const ctx = canvas.getContext('2d');

    // FIX: Set canvas parent height to prevent infinite expansion
    canvas.parentElement.style.height = '400px';
    canvas.parentElement.style.position = 'relative';

    const config = chartData.chartConfig || {};
    
    // Bar/Histogram charts
    if (chartData.chartType === 'bar' || chartData.chartType === 'histogram') {
        const colorPalette = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];
        const datasets = chartData.series.map((series, index) => ({
            label: series.name,
            data: series.values,
            backgroundColor: colorPalette[index % colorPalette.length],
            borderColor: colorPalette[index % colorPalette.length],
            borderWidth: 1
        }));
        
        const isHistogram = chartData.chartType === 'histogram';
        
        chartInstances[chartId] = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: chartData.xLabels || [],
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: datasets.length > 1
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        min: config.yAxis?.min,
                        max: config.yAxis?.max,
                        title: {
                            display: true,
                            text: config.yAxis?.title || chartData.yLabel || 'Value'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: config.xAxis?.title || chartData.xLabel || 'Category'
                        }
                    }
                }
            }
        });
    }
    
    // Pie chart
    else if (chartData.chartType === 'pie') {
        const seriesData = chartData.series[0].values;
        const labels = seriesData.map(item => item.name);
        const values = seriesData.map(item => item.value);
        
        chartInstances[chartId] = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: values,
                    backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom'
                    }
                }
            }
        });
    }
    
    // Scatter plot
    else if (chartData.chartType === 'scatter') {
        chartInstances[chartId] = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Data Points',
                    data: chartData.points,
                    backgroundColor: '#36A2EB',
                    borderColor: '#36A2EB',
                    pointRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        min: config.xAxis?.min,
                        max: config.xAxis?.max,
                        title: {
                            display: true,
                            text: config.xAxis?.title || chartData.xLabel || 'X Variable'
                        }
                    },
                    y: {
                        min: config.yAxis?.min,
                        max: config.yAxis?.max,
                        title: {
                            display: true,
                            text: config.yAxis?.title || chartData.yLabel || 'Y Variable'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }
    
    // Dotplot
    else if (chartData.chartType === 'dotplot') {
        const valueFrequency = {};
        chartData.values.forEach(value => {
            valueFrequency[value] = (valueFrequency[value] || 0) + 1;
        });
        
        const dotplotData = [];
        for (const [value, frequency] of Object.entries(valueFrequency)) {
            for (let i = 1; i <= frequency; i++) {
                dotplotData.push({
                    x: parseFloat(value),
                    y: i
                });
            }
        }
        
        chartInstances[chartId] = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Data Points',
                    data: dotplotData,
                    backgroundColor: '#36A2EB',
                    borderColor: '#36A2EB',
                    pointRadius: 4,
                    showLine: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        min: config.xAxis?.min,
                        max: config.xAxis?.max,
                        title: {
                            display: true,
                            text: config.xAxis?.title || 'Value'
                        }
                    },
                    y: {
                        min: 0,
                        max: Math.max(...Object.values(valueFrequency)) + 1,
                        display: false
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }
    
    // Boxplot
    else if (chartData.chartType === 'boxplot') {
        const boxplotData = config.boxplotData || {};
        const { Q1, Q3, median, min, max } = boxplotData;
        
        // Create a simple representation using bar chart
        chartInstances[chartId] = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Min', 'Q1', 'Median', 'Q3', 'Max'],
                datasets: [{
                    label: 'Five Number Summary',
                    data: [min, Q1, median, Q3, max],
                    backgroundColor: '#36A2EB'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: config.xAxis?.title || 'Value'
                        }
                    }
                }
            }
        });
    }
}

// Complete table rendering
function renderTable(table) {
    if (!table) return '';
    
    let html = '<div class="table-container"><table>';
    
    // Handle object format with headers and rows
    if (table.headers && table.rows) {
        html += '<thead><tr>';
        table.headers.forEach(header => {
            html += `<th>${header}</th>`;
        });
        html += '</tr></thead><tbody>';
        
        table.rows.forEach(row => {
            html += '<tr>';
            row.forEach(cell => {
                html += `<td>${cell}</td>`;
            });
            html += '</tr>';
        });
        html += '</tbody>';
    }
    // Handle array format (legacy)
    else if (Array.isArray(table) && table.length > 0) {
        const headers = table[0];
        const rows = table.slice(1);
        
        html += '<thead><tr>';
        headers.forEach(header => {
            html += `<th>${header}</th>`;
        });
        html += '</tr></thead>';
        
        if (rows.length > 0) {
            html += '<tbody>';
            rows.forEach(row => {
                html += '<tr>';
                row.forEach(cell => {
                    html += `<td>${cell}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody>';
        }
    }
    
    html += '</table></div>';
    return html;
}

// Updated renderAttachments to handle multiple charts
function renderAttachments(attachments, questionId) {
    let html = '';
    
    // Handle multiple charts
    if (attachments.charts && Array.isArray(attachments.charts)) {
        attachments.charts.forEach((chart, idx) => {
            html += renderChart(chart, `${questionId}-chart-${idx}`);
        });
    }
    // Handle single chart
    else if (attachments.chartType) {
        html += renderChart(attachments, `${questionId}-chart`);
    }
    
    // Handle tables
    if (attachments.table) {
        html += renderTable(attachments.table);
    }
    
    // Handle images
    if (attachments.image) {
        const imageAlt = attachments.imageAlt || 'Question image';
        const imageCaption = attachments.imageCaption || '';
        html += `
            <div class="image-container">
                <img src="${attachments.image}" alt="${imageAlt}" style="max-width: 100%; height: auto;">
                ${imageCaption ? `<div style="text-align: center; font-style: italic; color: #666; margin-top: 5px;">${imageCaption}</div>` : ''}
            </div>
        `;
    }
    
    // Handle multiple images
    if (attachments.images && Array.isArray(attachments.images)) {
        html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">';
        attachments.images.forEach(img => {
            html += `
                <div style="flex: 1; min-width: 200px; max-width: 400px;">
                    <img src="${img.url || img}" alt="${img.alt || 'Image'}" style="width: 100%; height: auto;">
                    ${img.caption ? `<div style="text-align: center; font-style: italic; color: #666; margin-top: 5px;">${img.caption}</div>` : ''}
                </div>
            `;
        });
        html += '</div>';
    }
    
    return html;
}

        // Render visible charts
        function renderVisibleCharts() {
            const chartContainers = document.querySelectorAll('[data-chart-id]');
            chartContainers.forEach(container => {
                const chartId = container.dataset.chartId;
                if (window.pendingCharts && window.pendingCharts[chartId]) {
                    renderChartNow(chartId);
                    delete window.pendingCharts[chartId];
                }
            });
        }

        // Actually render a chart
        function renderChartNow(chartId) {
            const canvas = document.getElementById(chartId);
            if (!canvas) return;

            // FIX: Check if chart already exists and destroy it
            if (chartInstances[chartId]) {
                chartInstances[chartId].destroy();
                delete chartInstances[chartId];
            }

            const chartData = window.pendingCharts[chartId];
            if (!chartData) return;

            const ctx = canvas.getContext('2d');

            // FIX: Set canvas parent height to prevent infinite expansion
            canvas.parentElement.style.height = '400px';
            canvas.parentElement.style.position = 'relative';

            const config = chartData.chartConfig || {};
            
            // Simple bar/histogram chart
            if (chartData.chartType === 'bar' || chartData.chartType === 'histogram') {
                const datasets = chartData.series.map(series => ({
                    label: series.name,
                    data: series.values,
                    backgroundColor: '#36A2EB',
                    borderColor: '#36A2EB',
                    borderWidth: 1
                }));
                
                chartInstances[chartId] = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: chartData.xLabels || [],
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: config.yAxis?.title || 'Value'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: config.xAxis?.title || 'Category'
                                }
                            }
                        }
                    }
                });
            }
            // Add other chart types as needed
        }

        // Submit answer
        window.submitAnswer = function(questionId, questionType) {
            if (!currentUsername) {
                showMessage('Please enter your username first!', 'error');
                return;
            }

            const errorSpan = document.getElementById(`error-${questionId}`);
            const successSpan = document.getElementById(`success-${questionId}`);
            
            // Clear previous messages
            if (errorSpan) {
                errorSpan.textContent = '';
                errorSpan.classList.remove('show');
            }
            if (successSpan) {
                successSpan.textContent = '';
                successSpan.classList.remove('show');
            }

            // Get current attempt count
            const attempts = getAttemptCount(questionId);
            
            // Check if can retry
            if (attempts > 0 && !canRetry(questionId)) {
                if (errorSpan) {
                    errorSpan.textContent = attempts >= 3 ? 
                        'Maximum attempts reached (3).' : 
                        'Please provide reasoning with your previous answer to enable retry.';
                    errorSpan.classList.add('show');
                }
                return;
            }

            // Get answer value
            let value = '';
            if (questionType === 'multiple-choice') {
                const selectedRadio = document.querySelector(`input[name="choice-${questionId}"]:checked`);
                if (!selectedRadio) {
                    if (errorSpan) {
                        errorSpan.textContent = 'Please select an answer.';
                        errorSpan.classList.add('show');
                    }
                    return;
                }
                value = selectedRadio.value;
            } else {
                const textarea = document.getElementById(`frq-${questionId}`);
                if (!textarea || !textarea.value.trim()) {
                    if (errorSpan) {
                        errorSpan.textContent = 'Please enter a response.';
                        errorSpan.classList.add('show');
                    }
                    return;
                }
                value = textarea.value.trim();
            }

            // Get reason
            const reasonTextarea = document.getElementById(`reason-${questionId}`);
            const reason = reasonTextarea ? reasonTextarea.value.trim() : '';

            // If this is a retry (attempts > 0), reason is required
            if (attempts > 0 && !reason) {
                if (errorSpan) {
                    errorSpan.textContent = 'Reasoning is required for retry attempts.';
                    errorSpan.classList.add('show');
                }
                reasonTextarea.classList.add('required');
                reasonTextarea.focus();
                return;
            }

            // Save answer
            if (!classData.users[currentUsername]) {
                classData.users[currentUsername] = {
                    answers: {},
                    reasons: {},
                    timestamps: {},
                    attempts: {}
                };
            }

            // Get existing answer or create new one
            const existingAnswer = classData.users[currentUsername].answers[questionId];
            const version = existingAnswer ? (existingAnswer.version || 1) + 1 : 1;

            classData.users[currentUsername].answers[questionId] = {
                value: value,
                timestamp: Date.now(),
                deviceId: getDeviceId(),
                version: version
            };
            classData.users[currentUsername].reasons[questionId] = reason;
            classData.users[currentUsername].timestamps[questionId] = Date.now();
            classData.users[currentUsername].attempts[questionId] = attempts + 1;

            saveClassData();

            // Update UI
            const submitBtn = document.getElementById(`submit-${questionId}`);
            const qContainer = document.querySelector(`[data-question-id="${questionId}"]`);
            
            // Update button
            if (submitBtn) {
                if (!canRetry(questionId)) {
                    submitBtn.textContent = 'Max Attempts Reached';
                    submitBtn.disabled = true;
                } else {
                    submitBtn.textContent = 'Update Answer';
                }
            }

            // Show success message
            if (successSpan) {
                successSpan.textContent = 'Answer submitted successfully!';
                successSpan.classList.add('show');
                setTimeout(() => {
                    successSpan.classList.remove('show');
                }, 3000);
            }

            // Update header to show answered
            const header = qContainer.querySelector('.question-header');
            if (header && !header.querySelector('span[style*="color"]')) {
                header.innerHTML += '<span style="color: #a5d6a7;">✓ Answered</span>';
            }

            // Show/update dotplot immediately after submission
            const dotplotSection = document.getElementById(`dotplot-section-${questionId}`);

            // Ensure the section is visible
            if (!dotplotSection.classList.contains('show')) {
                dotplotSection.classList.add('show');
                dotplotSection.style.opacity = '0';
                setTimeout(() => {
                    dotplotSection.style.transition = 'opacity 0.3s ease';
                    dotplotSection.style.opacity = '1';
                }, 10);
            }

            // Always destroy existing chart to force complete refresh
            const chartId = `dotplot-${questionId}`;
            if (chartInstances[chartId]) {
                try {
                    chartInstances[chartId].destroy();
                } catch(e) {
                    console.log('Error destroying chart:', e);
                }
                delete chartInstances[chartId];
            }

            // Clear the canvas to ensure clean slate
            const canvas = document.getElementById(chartId);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            // Render the appropriate visualization with a small delay to ensure DOM is ready
            setTimeout(() => {
                if (questionType === 'multiple-choice') {
                    renderMCQDistribution(questionId);
                } else {
                    renderFRQResponses(questionId);
                }
            }, 50);
        }

        // Show dotplot
        function showDotplot(questionId, questionType) {
    const dotplotSection = document.getElementById(`dotplot-section-${questionId}`);
    if (!dotplotSection) return;

    // Always destroy existing chart first to force refresh
    if (chartInstances[`dotplot-${questionId}`]) {
        chartInstances[`dotplot-${questionId}`].destroy();
        delete chartInstances[`dotplot-${questionId}`];
    }

    // Show the section with animation
    if (!dotplotSection.classList.contains('show')) {
        dotplotSection.classList.add('show');
        dotplotSection.style.opacity = '0';
        setTimeout(() => {
            dotplotSection.style.transition = 'opacity 0.3s ease';
            dotplotSection.style.opacity = '1';
        }, 10);
    }

    if (questionType === 'multiple-choice') {
        // Use setTimeout to ensure DOM is ready and force re-render
        setTimeout(() => {
            renderMCQDistribution(questionId);
        }, 50);
    } else {
        renderFRQResponses(questionId);
    }
}

        // Render MCQ distribution
        function renderMCQDistribution(questionId) {
            const canvas = document.getElementById(`dotplot-${questionId}`);
            if (!canvas) return;

            // Fix canvas dimensions to prevent cropping
            const container = canvas.parentElement;
            container.style.height = '500px';  // Increased from 350px
            container.style.position = 'relative';
            container.style.overflow = 'visible';  // Changed from 'hidden' to 'visible'

            // Ensure the canvas itself has room
            canvas.style.height = '600px';  // Increased from 300px
            canvas.style.width = '100%';

            // Aggregate responses
            const choiceCounts = {};
            let totalCount = 0;
            const contributors = [];

            // Get the question to know all possible choices
            const question = currentQuestions.find(q => q.id === questionId);
            const allChoices = question?.choices || question?.attachments?.choices || [];

            // Initialize all choices with 0
            allChoices.forEach(choice => {
                choiceCounts[choice.key] = 0;
            });

            // Count actual responses
            for (let username in classData.users) {
                const userAnswer = classData.users[username].answers?.[questionId];
                if (userAnswer) {
                    const choice = userAnswer.value || userAnswer;
                    const reason = classData.users[username].reasons?.[questionId] || '';

                    choiceCounts[choice] = (choiceCounts[choice] || 0) + 1;
                    totalCount++;
                    contributors.push({
                        username: username,
                        choice: choice,
                        reason: reason
                    });
                }
            }

            // Create bar chart (like your example JSON)
            const ctx = canvas.getContext('2d');
            const choices = Object.keys(choiceCounts).sort();
            const counts = choices.map(c => choiceCounts[c] || 0);
            const relativeFrequencies = counts.map(c => totalCount > 0 ? c / totalCount : 0);

            // Destroy existing chart if any
            // Destroy existing chart if any
if (chartInstances[`dotplot-${questionId}`]) {
    chartInstances[`dotplot-${questionId}`].destroy();
    delete chartInstances[`dotplot-${questionId}`];  // Add just this line
}
            // Create bar chart with relative frequencies
            chartInstances[`dotplot-${questionId}`] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: choices,
                    datasets: [{
                        label: 'Relative Frequency',
                        data: relativeFrequencies,
                        backgroundColor: choices.map(c => {
                            // Highlight user's choice in different color
                            const userChoice = classData.users[currentUsername]?.answers?.[questionId];
                            const userChoiceValue = userChoice?.value || userChoice;
                            return c === userChoiceValue ? '#4CAF50' : '#36A2EB';
                        }),
                        borderColor: '#2196F3',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            bottom: 20
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                stepSize: 0.1,
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Relative Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Answer Choice'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    const percentage = (value * 100).toFixed(1);
                                    const count = counts[context.dataIndex];
                                    return `${percentage}% (${count} of ${totalCount} responses)`;
                                }
                            }
                        }
                    }
                }
            });

            // Add consensus coloring
            const maxFreq = Math.max(...relativeFrequencies);
            const consensusDiv = document.getElementById(`consensus-${questionId}`);
            if (maxFreq >= 0.7) {
                consensusDiv.style.backgroundColor = '#e8f5e9';
                consensusDiv.style.border = '2px solid #4CAF50';
            } else if (maxFreq >= 0.6) {
                consensusDiv.style.backgroundColor = '#fff3e0';
                consensusDiv.style.border = '2px solid #ff9800';
            } else {
                consensusDiv.style.backgroundColor = '#ffebee';
                consensusDiv.style.border = '2px solid #f44336';
            }

            // Show consensus message
            if (consensusDiv) {
                if (totalCount > 1) {
                    const modeIndex = relativeFrequencies.indexOf(maxFreq);
                    const mode = choices[modeIndex];
                    const percentage = (maxFreq * 100).toFixed(0);

                    // Check for consensus (70% or more agreement)
                    if (maxFreq >= 0.7) {
                        consensusDiv.innerHTML = `
                            <div class="consensus-msg consensus">
                                ✓ Consensus reached on choice ${mode} (${percentage}% agreement)
                            </div>
                        `;
                    } else {
                        consensusDiv.innerHTML = `
                            <div class="consensus-msg no-consensus">
                                No consensus yet - highest agreement: ${mode} at ${percentage}%
                            </div>
                        `;
                    }
                } else {
                    consensusDiv.innerHTML = `
                        <div class="consensus-msg no-consensus">
                            You're the first to answer! Import class data to see peer responses.
                        </div>
                    `;
                }
            }

            // Show contributors with their choices and reasons
            const contributorsDiv = document.getElementById(`contributors-${questionId}`);
            if (contributorsDiv && contributors.length > 0) {
                let html = '<h4 style="margin-top: 10px;">Individual Responses:</h4>';
                contributors.forEach(c => {
                    const isCurrentUser = c.username === currentUsername;
                    const badges = calculateBadges(c.username);
                    const badgeText = badges.length > 0 ? ` ${badges.join(' ')}` : '';
                    html += `
                        <div class="contributor-item" style="${isCurrentUser ? 'background: #e3f2fd;' : ''}">
                            <span class="contributor-choice">${c.username}${badgeText} → Choice ${c.choice}</span>
                            ${c.reason ? `<div class="contributor-reason">"${c.reason}"</div>` : ''}
                        </div>
                    `;
                });
                contributorsDiv.innerHTML = html;
            }
        }

        // Render FRQ responses
        function renderFRQResponses(questionId) {
            const canvas = document.getElementById(`dotplot-${questionId}`);
            const consensusDiv = document.getElementById(`consensus-${questionId}`);
            const contributorsDiv = document.getElementById(`contributors-${questionId}`);
            
            if (canvas) canvas.style.display = 'none';
            
            const responses = [];
            for (let username in classData.users) {
                const userAnswer = classData.users[username].answers?.[questionId];
                if (userAnswer) {
                    const response = userAnswer.value || userAnswer;
                    const reason = classData.users[username].reasons?.[questionId] || '';
                    responses.push({
                        username: username,
                        response: response,
                        reason: reason
                    });
                }
            }
            
            if (consensusDiv) {
                if (responses.length > 1) {
                    consensusDiv.innerHTML = `
                        <div class="consensus-msg no-consensus">
                            ${responses.length} responses submitted. Review peer responses below.
                        </div>
                    `;
                } else {
                    consensusDiv.innerHTML = `
                        <div class="consensus-msg no-consensus">
                            Your response recorded. Import class data to see peer responses.
                        </div>
                    `;
                }
            }
            
            if (contributorsDiv) {
                let html = '<h4>Responses:</h4>';
                responses.forEach(r => {
                    const userVotes = classData.users[currentUsername]?.votes?.[questionId]?.[r.username] || {};
                    html += `
                        <div class="contributor-item">
                            <strong>${r.username}:</strong>
                            <div style="margin-top: 5px; padding: 10px; background: #f5f5f5; border-radius: 4px;">
                                ${r.response}
                            </div>
                            ${r.reason ? `<div class="contributor-reason">${r.reason}</div>` : ''}
                            <div style="margin-top: 10px;">
                                <button onclick="voteFRQ('${questionId}', '${r.username}', 'helpful')"
                                        class="vote-btn ${userVotes.type === 'helpful' ? 'active' : ''}">
                                    💡 Helpful (${getVoteCount(questionId, r.username, 'helpful')})
                                </button>
                                <button onclick="voteFRQ('${questionId}', '${r.username}', 'unclear')"
                                        class="vote-btn ${userVotes.type === 'unclear' ? 'active' : ''}">
                                    🤔 Unclear (${getVoteCount(questionId, r.username, 'unclear')})
                                </button>
                                <button onclick="voteFRQ('${questionId}', '${r.username}', 'contradicts')"
                                        class="vote-btn ${userVotes.type === 'contradicts' ? 'active' : ''}">
                                    ⚔️ Contradicts (${getVoteCount(questionId, r.username, 'contradicts')})
                                </button>
                            </div>
                        </div>
                    `;
                });
                contributorsDiv.innerHTML = html;
            }
        }

        // Helper function to get vote count
        function getVoteCount(questionId, targetUser, voteType) {
            let count = 0;
            for (let username in classData.users) {
                const userVotes = classData.users[username].votes?.[questionId]?.[targetUser];
                if (userVotes?.type === voteType) {
                    count++;
                }
            }
            return count;
        }

        // Vote FRQ function
        window.voteFRQ = function(questionId, targetUser, voteType) {
            if (!classData.users[currentUsername].votes) {
                classData.users[currentUsername].votes = {};
            }
            if (!classData.users[currentUsername].votes[questionId]) {
                classData.users[currentUsername].votes[questionId] = {};
            }

            const existingVote = classData.users[currentUsername].votes[questionId][targetUser];
            if (existingVote?.type === voteType) {
                // Remove vote if clicking same button
                delete classData.users[currentUsername].votes[questionId][targetUser];
            } else {
                // Set new vote
                classData.users[currentUsername].votes[questionId][targetUser] = {
                    type: voteType,
                    timestamp: Date.now()
                };
            }

            saveClassData();
            renderFRQResponses(questionId);
        }

        // Load progress
        function loadProgress() {
            if (!currentUsername || !classData) return;
            
            currentQuestions.forEach(question => {
                const qId = question.id;
                const qContainer = document.querySelector(`[data-question-id="${qId}"]`);
                if (!qContainer) return;
                
                const isAnswered = isQuestionAnswered(qId);
                if (isAnswered) {
                    // Show dotplot if answered
                    const questionType = question.type;
                    showDotplot(qId, questionType);
                    
                    // Update button state
                    const submitBtn = document.getElementById(`submit-${qId}`);
                    if (submitBtn) {
                        if (!canRetry(qId)) {
                            submitBtn.textContent = 'Max Attempts Reached';
                            submitBtn.disabled = true;
                        } else {
                            submitBtn.textContent = 'Update Answer';
                        }
                    }
                }
            });
        }

        // Export personal data
        window.exportPersonal = function() {
            const personalData = {
                exportTime: Date.now(),
                username: currentUsername,
                users: {
                    [currentUsername]: classData.users[currentUsername]
                }
            };
            
            const blob = new Blob([JSON.stringify(personalData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentUsername}_data.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage('Personal data exported successfully!', 'success');
        }

        // Add button to export section
        function addExportQRButton() {
            return `
                <button onclick="showExportQR()" class="sync-button">
                    📊 Show QR (Recent Changes)
                </button>
            `;
        }

        window.showMyQR = function() {
            // Prepare data packet with only recent changes
            const cutoff = classData.lastSyncTime || 0;
            const myData = {
                username: currentUsername,
                timestamp: Date.now(),
                changes: {}
            };

            const user = classData.users[currentUsername];
            let changeCount = 0;

            Object.keys(user.answers || {}).forEach(qId => {
                if ((user.timestamps?.[qId] || 0) > cutoff) {
                    myData.changes[qId] = {
                        answer: user.answers[qId],
                        reason: user.reasons?.[qId],
                        timestamp: user.timestamps?.[qId]
                    };
                    changeCount++;
                }
            });

            const json = JSON.stringify(myData);
            if (json.length > 2500) {
                alert('Too much data for QR. Please export to file instead.');
                return;
            }

            // Show QR modal
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 2000; display: flex; align-items: center; justify-content: center;';
            modal.onclick = function() { this.remove(); };
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 10px; text-align: center;" onclick="event.stopPropagation()">
                    <h2>${currentUsername}</h2>
                    <p>${changeCount} answers to sync</p>
                    <div id="my-qr"></div>
                    <button onclick="this.closest('[style*=fixed]').remove()" class="submit-button" style="margin-top: 20px;">Close</button>
                </div>
            `;
            document.body.appendChild(modal);

            new QRCode(document.getElementById('my-qr'), {
                text: btoa(json),
                width: 300,
                height: 300
            });
        }

        // Import class data
        window.importClassData = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    mergeClassData(imported);
                    showMessage(`Imported data from ${Object.keys(imported.users).length} users`, 'success');
                    
                    // Re-render dotplots to show new data
                    loadProgress();
                } catch(err) {
                    showMessage('Error importing file: Invalid JSON format', 'error');
                }
            };
            reader.readAsText(file);
        }

        // Simplified sync menu with role-based options
        function renderSyncButtons() {
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            const isDesktop = !isMobile;

            return `
                <button onclick="openSimpleSyncMenu()" class="sync-button" style="background: #2196F3;">
                    🔄 Sync & Save
                </button>
            `;
        }

        window.quickExport = function() {
            exportPersonal();
            showMessage('Your answers have been saved!', 'success');
        }

        window.openSimpleSyncMenu = function() {
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 2000; display: flex; align-items: center; justify-content: center;';
            modal.onclick = function(e) { if(e.target === modal) modal.remove(); };

            let menuContent = '';

            if (isMobile) {
                // Phone menu - Teacher role for QR-Keyboard sync
                menuContent = `
                    <h2 style="margin-top: 0; text-align: center;">📱 Phone Menu</h2>

                    <button onclick="startTeacherQRKeyboard(); this.closest('[style*=fixed]').remove();"
                            class="sync-button" style="width: 100%; margin-bottom: 10px; background: #9C27B0;">
                        🎯 Collect from Students
                        <div style="font-size: 12px; opacity: 0.8;">Scan QRs & give codes</div>
                    </button>

                    <button onclick="enterTransferCode(); this.closest('[style*=fixed]').remove();"
                            class="sync-button" style="width: 100%; margin-bottom: 10px; background: #4CAF50;">
                        📥 Get from Desktop
                        <div style="font-size: 12px; opacity: 0.8;">Enter a 6-character code</div>
                    </button>

                    <button onclick="startSmartSync(); this.closest('[style*=fixed]').remove();"
                            class="sync-button" style="width: 100%; margin-bottom: 10px; background: #2196F3;">
                        📷 Scan Another Phone
                        <div style="font-size: 12px; opacity: 0.8;">Use camera to scan QR</div>
                    </button>

                    <button onclick="showMyQR(); this.closest('[style*=fixed]').remove();"
                            class="sync-button" style="width: 100%; margin-bottom: 10px;">
                        📤 Share My Answers
                        <div style="font-size: 12px; opacity: 0.8;">Show QR to another phone</div>
                    </button>
                `;
            } else {
                // Desktop menu - Student role for QR-Keyboard sync
                menuContent = `
                    <h2 style="margin-top: 0; text-align: center;">💻 Desktop Menu</h2>

                    <button onclick="startStudentQRKeyboard(); this.closest('[style*=fixed]').remove();"
                            class="sync-button" style="width: 100%; margin-bottom: 10px; background: #9C27B0;">
                        📤 Send to Teacher
                        <div style="font-size: 12px; opacity: 0.8;">Show QR & type codes</div>
                    </button>

                    <button onclick="shareViaCode(); this.closest('[style*=fixed]').remove();"
                            class="sync-button" style="width: 100%; margin-bottom: 10px; background: #4CAF50;">
                        📤 Send to Phone
                        <div style="font-size: 12px; opacity: 0.8;">Get a code to enter on phone</div>
                    </button>

                    <button onclick="quickExport(); this.closest('[style*=fixed]').remove();"
                            class="sync-button" style="width: 100%; margin-bottom: 10px;">
                        💾 Save to File
                        <div style="font-size: 12px; opacity: 0.8;">Download your answers</div>
                    </button>
                `;
            }

            // Audio transfer option (both mobile and desktop)
            menuContent += `
                <button onclick="showAudioSync(); this.closest('[style*=fixed]').remove();"
                        class="sync-button" style="width: 100%; margin-bottom: 10px; background: #FF9800;">
                    🔊 Audio Transfer
                    <div style="font-size: 12px; opacity: 0.8;">Transfer via sound waves</div>
                </button>
            `;

            // File import option (both)
            menuContent += `
                <input type="file" id="import-input" accept=".json" style="display:none;"
                       onchange="importClassData(event); this.closest('[style*=fixed]').remove();">
                <button onclick="document.getElementById('import-input').click();"
                        class="sync-button" style="width: 100%; margin-bottom: 20px;">
                    📁 Load from File
                    <div style="font-size: 12px; opacity: 0.8;">Import saved data</div>
                </button>
            `;

            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 10px; max-width: 350px; width: 90%;">
                    ${menuContent}

                    <button onclick="this.closest('[style*=fixed]').remove()"
                            style="width: 100%; padding: 10px; background: none;
                                   border: 1px solid #ccc; border-radius: 4px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // Merge imported data with existing data
        function mergeClassData(imported) {
            if (!imported.users) return;
            
            for (let username in imported.users) {
                if (!classData.users[username]) {
                    classData.users[username] = {
                        answers: {},
                        reasons: {},
                        timestamps: {},
                        attempts: {}
                    };
                }
                
                const importedUser = imported.users[username];
                const localUser = classData.users[username];
                
                // Merge answers based on timestamp
                for (let qId in importedUser.answers) {
                    const importedTs = importedUser.timestamps?.[qId] || 0;
                    const localTs = localUser.timestamps?.[qId] || 0;
                    
                    if (importedTs > localTs) {
                        localUser.answers[qId] = importedUser.answers[qId];
                        localUser.reasons[qId] = importedUser.reasons?.[qId] || '';
                        localUser.timestamps[qId] = importedTs;
                        localUser.attempts[qId] = importedUser.attempts?.[qId] || 1;
                    }
                }
            }

            // When importing data:
            classData.lastImportTime = Date.now();

            saveClassData();
        }

        function mergeIncomingData(incoming) {
            const mergeReport = {
                newUsers: 0,
                updatedAnswers: 0,
                conflicts: []
            };

            Object.keys(incoming.users).forEach(username => {
                if (!classData.users[username]) {
                    classData.users[username] = incoming.users[username];
                    mergeReport.newUsers++;
                } else {
                    // Merge by most recent timestamp per question
                    const localUser = classData.users[username];
                    const remoteUser = incoming.users[username];

                    Object.keys(remoteUser.answers).forEach(qId => {
                        const localTime = localUser.timestamps?.[qId] || 0;
                        const remoteTime = remoteUser.timestamps?.[qId] || 0;

                        if (remoteTime > localTime) {
                            // Remote is newer - take it
                            localUser.answers[qId] = remoteUser.answers[qId];
                            localUser.timestamps[qId] = remoteTime;
                            localUser.reasons[qId] = remoteUser.reasons[qId];
                            localUser.attempts[qId] = remoteUser.attempts[qId];
                            mergeReport.updatedAnswers++;
                        } else if (remoteTime === localTime &&
                                  JSON.stringify(localUser.answers[qId]) !==
                                  JSON.stringify(remoteUser.answers[qId])) {
                            // Same timestamp, different answer = conflict
                            mergeReport.conflicts.push({
                                user: username,
                                question: qId,
                                local: localUser.answers[qId],
                                remote: remoteUser.answers[qId]
                            });
                        }
                    });
                }
            });

            // Update sync tracking
            classData.lastSyncTime = Date.now();
            classData.syncHistory.push({
                time: Date.now(),
                source: incoming.deviceId || 'unknown',
                stats: mergeReport
            });

            return mergeReport;
        }

        // Show message
        function showMessage(text, type) {
            const messageArea = document.getElementById('messageArea');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;
            
            messageArea.innerHTML = '';
            messageArea.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.opacity = '0';
                setTimeout(() => messageArea.innerHTML = '', 300);
            }, 5000);
        }

        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('quizTheme') || 'light';
            currentTheme = savedTheme;
            applyTheme(savedTheme);
        }

        function applyTheme(theme) {
            const body = document.body;
            const themeButton = document.querySelector('.theme-toggle');
            
            if (theme === 'dark') {
                body.classList.add('dark-theme');
                if (themeButton) themeButton.textContent = '☀️';
            } else {
                body.classList.remove('dark-theme');
                if (themeButton) themeButton.textContent = '🌙';
            }
            
            currentTheme = theme;
            localStorage.setItem('quizTheme', theme);
        }

        window.toggleTheme = function() {
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }

        // Initialize on load
        window.onload = function() {
            // Load curriculum resources first, then initialize the app
            loadCurriculumResources()
                .then(() => {
                    console.log('Curriculum resources loaded successfully, initializing app...');
                    initTheme();

                    // Check localStorage support
                    if (!window.localStorage) {
                        showMessage('Warning: LocalStorage is not available. Data will not be saved.', 'error');
                    }

                    promptUsername();
                })
                .catch(error => {
                    console.error('Failed to load curriculum resources:', error);
                    // Show user-friendly error message and continue with basic functionality
                    showMessage('Some curriculum resources failed to load. The app will work with limited functionality.', 'warning');

                    // Still initialize the app with available resources
                    initTheme();

                    // Check localStorage support
                    if (!window.localStorage) {
                        showMessage('Warning: LocalStorage is not available. Data will not be saved.', 'error');
                    }

                    promptUsername();
                });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+S to export data
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (currentUsername) {
                    exportPersonal();
                }
            }
        });

        // Intersection Observer for lazy loading charts (optional enhancement)
        if ('IntersectionObserver' in window) {
            const chartObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const container = entry.target;
                        const chartId = container.dataset.chartId;
                        if (chartId && window.pendingCharts && window.pendingCharts[chartId]) {
                            renderChartNow(chartId);
                            delete window.pendingCharts[chartId];
                            chartObserver.unobserve(container);
                        }
                    }
                });
            }, {
                rootMargin: '100px'
            });
            
            // Observe chart containers when they're created
            window.observeChartContainers = function() {
                document.querySelectorAll('[data-chart-id]').forEach(container => {
                    chartObserver.observe(container);
                });
            }
        }


        // Pig Sprite Controller
        class PigSprite {
            constructor(color = 'pink') {
                this.x = window.innerWidth / 2;
                this.y = 100;
                this.frame = 0;
                this.animationRow = 0; // 0 for top row, 1 for bottom row
                this.facingRight = true;
                this.isJumping = false;
                this.velocity = { x: 0, y: 0 };
                this.color = color;

                this.createElement();
                this.bindControls();
                this.startAnimation();
            }

            createElement() {
                this.element = document.createElement('div');
                this.element.className = 'pig-sprite';
                this.element.style.left = this.x + 'px';
                this.element.style.bottom = this.y + 'px';

                // Apply color filter if needed
                if (this.color !== 'pink') {
                    this.element.style.filter = this.getColorFilter(this.color);
                }

                document.body.appendChild(this.element);
            }

            getColorFilter(color) {
                // CSS filters to change pig color
                const filters = {
                    'blue': 'hue-rotate(200deg)',
                    'green': 'hue-rotate(90deg)',
                    'purple': 'hue-rotate(270deg)',
                    'yellow': 'hue-rotate(45deg) saturate(1.5)',
                    'red': 'hue-rotate(-10deg) saturate(1.5)',
                    'gray': 'grayscale(100%)'
                };
                return filters[color] || '';
            }

            bindControls() {
                document.addEventListener('keydown', (e) => {
                    // Check if currently typing
                    const activeElement = document.activeElement;
                    const isTyping = activeElement && (
                        activeElement.tagName === 'TEXTAREA' ||
                        activeElement.tagName === 'INPUT' ||
                        activeElement.contentEditable === 'true'
                    );

                    if (isTyping) return; // Don't capture keys when typing

                    switch(e.key) {
                        case 'ArrowLeft':
                            this.moveLeft();
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            this.moveRight();
                            e.preventDefault();
                            break;
                        case 'ArrowUp':
                        case ' ':
                            this.jump();
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            this.animationRow = this.animationRow === 0 ? 1 : 0;
                            e.preventDefault();
                            break;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    // Check if currently typing
                    const activeElement = document.activeElement;
                    const isTyping = activeElement && (
                        activeElement.tagName === 'TEXTAREA' ||
                        activeElement.tagName === 'INPUT' ||
                        activeElement.contentEditable === 'true'
                    );

                    if (isTyping) return;

                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        this.velocity.x = 0;
                    }
                });
            }

            moveLeft() {
                this.velocity.x = -5;
                this.facingRight = false;
                this.element.classList.add('facing-left');
            }

            moveRight() {
                this.velocity.x = 5;
                this.facingRight = true;
                this.element.classList.remove('facing-left');
            }

            jump() {
                if (!this.isJumping) {
                    this.isJumping = true;
                    this.velocity.y = 15;

                    setTimeout(() => {
                        this.isJumping = false;
                    }, 500);
                }
            }

            updatePosition() {
                // Update horizontal position
                if (this.velocity.x !== 0) {
                    this.x += this.velocity.x;
                    this.x = Math.max(0, Math.min(window.innerWidth - 32, this.x));
                    this.element.style.left = this.x + 'px';
                }

                // Update vertical position (gravity simulation)
                if (this.velocity.y > 0 || this.y > 100) {
                    this.y += this.velocity.y;
                    this.velocity.y -= 0.8; // gravity

                    if (this.y <= 100) {
                        this.y = 100;
                        this.velocity.y = 0;
                    }

                    this.element.style.bottom = this.y + 'px';
                }
            }

            animate() {
                // Cycle through frames when moving
                if (this.velocity.x !== 0 || this.isJumping) {
                    this.frame = (this.frame + 1) % 11;
                } else {
                    this.frame = 0; // idle frame
                }

                // Update sprite background position
                const xOffset = -this.frame * 32;
                const yOffset = -this.animationRow * 32;
                this.element.style.backgroundPosition = `${xOffset}px ${yOffset}px`;
            }

            startAnimation() {
                setInterval(() => {
                    this.updatePosition();
                    this.animate();
                }, 50);
            }

            setColor(newColor) {
                this.color = newColor;
                this.element.style.filter = this.getColorFilter(newColor);

                // Save to localStorage with username
                if (currentUsername) {
                    localStorage.setItem(`pigColor_${currentUsername}`, newColor);
                }
            }
        }

        // Initialize the sprite when the page loads
        window.addEventListener('load', () => {
            // Wait for username to be set
            setTimeout(() => {
                if (currentUsername) {
                    // Load saved color for this user
                    const savedColor = localStorage.getItem(`pigColor_${currentUsername}`) || 'pink';
                    window.pigSprite = new PigSprite(savedColor);
                }
            }, 1000);
        });

        // Add color picker to the UI
        function addColorPicker() {
            const colorPicker = document.createElement('div');
            colorPicker.innerHTML = `
                <div style="position: fixed; bottom: 20px; left: 20px; background: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 1000;">
                    <label>Pig Color: </label>
                    <select id="pigColorSelect" onchange="if(window.pigSprite) window.pigSprite.setColor(this.value)">
                        <option value="pink">Pink</option>
                        <option value="blue">Blue</option>
                        <option value="green">Green</option>
                        <option value="purple">Purple</option>
                        <option value="yellow">Yellow</option>
                        <option value="red">Red</option>
                        <option value="gray">Gray</option>
                    </select>
                </div>
            `;
            document.body.appendChild(colorPicker);
        }

        // Add this to your window.onload
        window.addEventListener('load', () => {
            addColorPicker();
        });

        // Initialize it after the page loads
        window.addEventListener('load', function() {
            // Initialize QR sync manager
            qrSync = new QRSyncManager();
        });


    </script>

    <!-- Enhanced QR Sync System with Handshake Protocol -->
    <script>
        // Enhanced QR Sync System with Handshake Protocol
        // Here's the complete QRSyncManager class (fixed version):
        class QRSyncManager {
            constructor() {
                this.syncState = 'idle';
                this.syncSessionId = null;
                this.pendingData = null;
                this.receivedData = null;
            }

            initiateSyncSession() {
                this.syncSessionId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.syncState = 'initiating';
                this.createSyncUI();

                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    this.broadcastData();
                    this.startScanning();
                }, 100);
            }

            createSyncUI() {
                const modal = document.createElement('div');
                modal.id = 'sync-modal';
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.9); z-index: 3000;
                    display: flex; align-items: center; justify-content: center;
                `;

                modal.innerHTML = `
                    <div style="background: white; padding: 20px; border-radius: 10px; max-width: 800px; width: 90%;">
                        <h2 style="text-align: center; margin-bottom: 20px;">📱 Device Sync - Handshake Mode</h2>

                        <div style="display: flex; gap: 20px;">
                            <!-- Left side: Our QR code -->
                            <div style="flex: 1; text-align: center;">
                                <h3>Step 1: Show this to other device</h3>
                                <div id="our-qr-code" style="margin: 20px auto; width: 256px; height: 256px;"></div>
                                <div id="our-status" style="color: #666;">Generating QR code...</div>
                            </div>

                            <!-- Right side: Scanner -->
                            <div style="flex: 1; text-align: center;">
                                <h3>Step 2: Scan their code</h3>
                                <div id="qr-scanner" style="width: 100%; height: 256px; border: 2px dashed #ccc;"></div>
                                <div id="scan-status" style="color: #666;">Initializing camera...</div>
                            </div>
                        </div>

                        <!-- Handshake status -->
                        <div id="handshake-status" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; text-align: center;">
                            <strong>Handshake Status:</strong> <span id="status-text">Waiting for connection...</span>
                        </div>

                        <!-- Action buttons -->
                        <div style="margin-top: 20px; text-align: center;">
                            <button onclick="qrSync.confirmSync()" id="confirm-btn" class="submit-button" disabled>
                                Confirm Sync
                            </button>
                            <button onclick="qrSync.cancelSync()" class="submit-button" style="background: #f44336; margin-left: 10px;">
                                Cancel
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            broadcastData() {
                try {
                    // Use the efficient exportForQR function instead of sending all data
                    const compressed = exportForQR();

                    if (!compressed) {
                        // Too many changes - show warning
                        document.getElementById('our-status').innerHTML = '⚠️ Too many changes since last sync. Use file export instead.';
                        return;
                    }

                    // Decode to get the packet for internal use
                    const ourPacket = JSON.parse(atob(compressed));
                    ourPacket.sessionId = this.syncSessionId; // Add session ID for handshake

                    // Create QR code
                    new QRCode(document.getElementById("our-qr-code"), {
                        text: compressed,
                        width: 256,
                        height: 256,
                        correctLevel: QRCode.CorrectLevel.L
                    });

                    document.getElementById('our-status').innerHTML = '✅ QR Code ready!';
                    this.pendingData = ourPacket;
                } catch(e) {
                    console.error('Error creating QR:', e);
                    document.getElementById('our-status').innerHTML = '❌ Error creating QR code';
                }
            }

            startScanning() {
                const html5QrCode = new Html5Qrcode("qr-scanner");

                const config = {
                    fps: 10,
                    qrbox: { width: 200, height: 200 }
                };

                const onScanSuccess = (decodedText) => {
                    this.handleScannedData(decodedText, html5QrCode);
                };

                // Try to start camera
                html5QrCode.start(
                    { facingMode: "environment" },
                    config,
                    onScanSuccess
                ).then(() => {
                    document.getElementById('scan-status').innerHTML = '📷 Camera ready - point at QR code';
                }).catch(err => {
                    // Try front camera if rear fails
                    html5QrCode.start(
                        { facingMode: "user" },
                        config,
                        onScanSuccess
                    ).then(() => {
                        document.getElementById('scan-status').innerHTML = '📷 Camera ready - point at QR code';
                    }).catch(err => {
                        document.getElementById('scan-status').innerHTML = '❌ Camera not available';
                        console.error('Camera error:', err);
                    });
                });
            }

            handleScannedData(decodedText, scanner) {
                try {
                    // Try to decompress first (new compressed format)
                    let decoded = decompressData(decodedText);

                    // If decompression fails, fall back to original format
                    if (!decoded) {
                        decoded = JSON.parse(atob(decodedText));
                    }

                    if (decoded.sessionId && decoded.data) {
                        this.receivedData = decoded;

                        document.getElementById('scan-status').innerHTML =
                            `✅ Received data from ${decoded.username || 'Unknown User'}`;
                        document.getElementById('status-text').innerHTML =
                            `🤝 Handshake established! Ready to sync.`;

                        document.getElementById('confirm-btn').disabled = false;

                        scanner.stop();

                        // Auto-confirm after a moment
                        setTimeout(() => this.confirmSync(), 1500);
                    }
                } catch(e) {
                    console.error('Invalid QR data:', e);
                }
            }

            confirmSync() {
                if (!this.receivedData) {
                    alert('No data received from other device yet!');
                    return;
                }

                // Handle both old format (full data) and new format (changes only)
                let imported;
                if (this.receivedData.changes) {
                    // New format: apply changes to existing user data
                    imported = {
                        users: {
                            [this.receivedData.username]: {
                                answers: {},
                                reasons: {},
                                timestamps: {},
                                attempts: {}
                            }
                        }
                    };

                    // Apply each change
                    Object.keys(this.receivedData.changes).forEach(qId => {
                        const change = this.receivedData.changes[qId];
                        imported.users[this.receivedData.username].answers[qId] = change.answer;
                        imported.users[this.receivedData.username].reasons[qId] = change.reason;
                        imported.users[this.receivedData.username].timestamps[qId] = change.timestamp;
                        imported.users[this.receivedData.username].attempts[qId] = change.attempts;
                    });
                } else if (this.receivedData.data) {
                    // Old format: full user data
                    imported = {
                        users: {
                            [this.receivedData.username]: this.receivedData.data
                        }
                    };
                } else {
                    alert('Invalid data format received!');
                    return;
                }

                mergeClassData(imported);

                // Update sync time to current time
                classData.lastSyncTime = Date.now();
                localStorage.setItem('classData', JSON.stringify(classData));

                document.getElementById('handshake-status').innerHTML = `
                    <div style="color: #4CAF50; font-size: 20px;">
                        ✅ Sync Complete!<br>
                        <small>Exchanged data with ${this.receivedData.username}</small>
                    </div>
                `;

                loadProgress();

                setTimeout(() => this.cancelSync(), 2000);
            }

            cancelSync() {
                // Stop any running camera
                try {
                    const scanner = Html5Qrcode.getCameras();
                    if (scanner) {
                        Html5Qrcode.stop();
                    }
                } catch(e) {}

                const modal = document.getElementById('sync-modal');
                if (modal) modal.remove();
                this.syncState = 'idle';
                this.receivedData = null;
                this.pendingData = null;
            }

        }

        // CRC8 checksum calculation for error detection
        function crc8(data) {
            const polynomial = 0x07; // CRC-8-CCITT polynomial
            let crc = 0x00;

            for (let i = 0; i < data.length; i++) {
                crc ^= data.charCodeAt(i);
                for (let j = 0; j < 8; j++) {
                    if (crc & 0x80) {
                        crc = (crc << 1) ^ polynomial;
                    } else {
                        crc <<= 1;
                    }
                }
                crc &= 0xFF; // Keep it 8-bit
            }
            return crc;
        }

        // Calculate CRC for received packet
        function calculateCRC(packet) {
            const data = packet.data;
            return crc8(data);
        }

        // Chunked QR Code Transfer System with Error Detection & Retransmission
        class ChunkedQRTransfer {
            constructor() {
                this.chunks = [];
                this.currentChunk = 0;
                this.scannedChunks = {};
                this.expectedChunks = 0;
                this.retransmissionRequests = new Set(); // Track chunks that need retransmission
                this.ackPackets = {}; // Store successful acknowledgments
            }

            // Sender side - create chunks
            prepareChunks() {
                const MAX_CHUNK_SIZE = 500; // Much smaller for better scanning

                // Get all user data
                const fullData = {
                    username: currentUsername,
                    answers: classData.users[currentUsername].answers,
                    reasons: classData.users[currentUsername].reasons,
                    timestamps: classData.users[currentUsername].timestamps
                };

                const jsonStr = JSON.stringify(fullData);
                const encoded = btoa(jsonStr);

                // Split into chunks
                this.chunks = [];
                for (let i = 0; i < encoded.length; i += MAX_CHUNK_SIZE) {
                    this.chunks.push(encoded.substr(i, MAX_CHUNK_SIZE));
                }

                return this.chunks.length;
            }

            // Show chunked QR interface
            showChunkedTransfer() {
                const totalChunks = this.prepareChunks();

                const modal = document.createElement('div');
                modal.id = 'chunked-transfer';
                modal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 3000; padding: 20px;';
                modal.innerHTML = `
                    <div style="max-width: 500px; margin: 0 auto; text-align: center;">
                        <h2>📦 Data Transfer (${totalChunks} parts)</h2>
                        <p>Have the other device scan each QR code in order</p>

                        <div style="margin: 20px 0;">
                            <h3>Part <span id="chunk-num">1</span> of ${totalChunks}</h3>
                            <div id="chunk-qr" style="margin: 20px auto;"></div>
                        </div>

                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button onclick="chunkedTransfer.prevChunk()" id="prev-btn" class="submit-button" disabled>
                                ← Previous
                            </button>
                            <button onclick="chunkedTransfer.nextChunk()" id="next-btn" class="submit-button">
                                Next →
                            </button>
                            <button onclick="chunkedTransfer.cancel()" class="submit-button" style="background: #f44336;">
                                Cancel
                            </button>
                        </div>

                        <div style="margin-top: 20px; padding: 10px; background: #f0f0f0; border-radius: 5px;">
                            <small>Tip: Wait for "Success!" on receiver before moving to next</small>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                this.showCurrentChunk();
            }

            showCurrentChunk() {
                const qrDiv = document.getElementById('chunk-qr');
                qrDiv.innerHTML = ''; // Clear previous

                const chunkData = {
                    seq: this.currentChunk,        // Sequence number
                    data: this.chunks[this.currentChunk],   // Actual data
                    crc: crc8(this.chunks[this.currentChunk]), // CRC checksum
                    total: this.chunks.length,
                    username: currentUsername
                };

                new QRCode(qrDiv, {
                    text: JSON.stringify(chunkData),
                    width: 256,
                    height: 256,
                    correctLevel: QRCode.CorrectLevel.L
                });

                document.getElementById('chunk-num').textContent = this.currentChunk + 1;
                document.getElementById('prev-btn').disabled = this.currentChunk === 0;
                document.getElementById('next-btn').disabled = this.currentChunk === this.chunks.length - 1;
            }

            nextChunk() {
                if (this.currentChunk < this.chunks.length - 1) {
                    this.currentChunk++;
                    this.showCurrentChunk();
                }
            }

            prevChunk() {
                if (this.currentChunk > 0) {
                    this.currentChunk--;
                    this.showCurrentChunk();
                }
            }

            cancel() {
                document.getElementById('chunked-transfer')?.remove();
            }

            // Receiver side
            startChunkedReceive() {
                const modal = document.createElement('div');
                modal.id = 'chunked-receive';
                modal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 3000; padding: 20px;';
                modal.innerHTML = `
                    <div style="max-width: 500px; margin: 0 auto;">
                        <h2>📥 Receive Data in Parts</h2>
                        <p>Scan each QR code shown on the sender's device</p>

                        <div id="chunk-scanner" style="width: 100%; height: 300px;"></div>

                        <div style="margin: 20px 0; padding: 15px; background: #f0f0f0; border-radius: 5px;">
                            <h3>Progress</h3>
                            <div id="chunk-progress">Waiting for first part...</div>
                            <div id="chunks-received" style="margin-top: 10px;"></div>
                        </div>

                        <button onclick="chunkedTransfer.cancelReceive()" class="submit-button" style="background: #f44336;">
                            Cancel
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);

                this.startChunkScanner();
            }

            startChunkScanner() {
                const html5QrCode = new Html5Qrcode("chunk-scanner");

                const config = {
                    fps: 10,
                    qrbox: { width: 250, height: 250 }
                };

                const onScanSuccess = (decodedText) => {
                    this.handleScannedChunk(decodedText, html5QrCode);
                };

                // Try to start camera
                html5QrCode.start(
                    { facingMode: "environment" },
                    config,
                    onScanSuccess
                ).catch(err => {
                    document.getElementById('chunk-progress').innerHTML =
                        '❌ Camera error. Please allow camera access and reload.';
                });

                this.currentScanner = html5QrCode;
            }

            handleScannedChunk(decodedText, scanner) {
                try {
                    const chunk = JSON.parse(decodedText);

                    // Handle retransmission requests from receiver
                    if (chunk.type === 'retransmit') {
                        this.handleRetransmitRequest(chunk, scanner);
                        return;
                    }

                    // Handle acknowledgment packets
                    if (chunk.type === 'ack') {
                        this.handleAcknowledgment(chunk, scanner);
                        return;
                    }

                    // Handle regular data chunks
                    if (chunk.seq !== undefined && chunk.data && chunk.crc !== undefined) {
                        this.processChunk(chunk, scanner);
                    }
                } catch(e) {
                    console.error('Invalid chunk:', e);
                }
            }

            processChunk(chunk, scanner) {
                // Verify CRC checksum
                const calculatedCRC = calculateCRC(chunk);
                if (calculatedCRC !== chunk.crc) {
                    console.warn(`CRC mismatch for chunk ${chunk.seq}. Expected: ${chunk.crc}, Got: ${calculatedCRC}`);
                    this.requestRetransmit(chunk.seq, scanner);
                    return;
                }

                // Store the chunk
                this.scannedChunks[chunk.seq] = chunk.data;
                this.expectedChunks = chunk.total;

                // Send acknowledgment
                this.sendAcknowledgment(chunk.seq, scanner);

                // Update progress
                const received = Object.keys(this.scannedChunks).length;
                document.getElementById('chunk-progress').innerHTML =
                    `Received ${received} of ${chunk.total} parts`;

                // Show which chunks we have
                let progressHTML = '';
                for (let i = 0; i < chunk.total; i++) {
                    if (this.scannedChunks[i] !== undefined) {
                        progressHTML += `✅ Part ${i + 1} `;
                    } else {
                        progressHTML += `⬜ Part ${i + 1} `;
                    }
                }
                document.getElementById('chunks-received').innerHTML = progressHTML;

                // Check if complete
                if (received === chunk.total) {
                    scanner.stop();
                    this.assembleAndImport(chunk.username);
                }
            }

            // Request retransmission of a corrupted chunk
            requestRetransmit(seq, scanner) {
                const retransmitRequest = {
                    type: 'retransmit',
                    seq: seq,
                    timestamp: Date.now()
                };

                // Show retransmission request QR
                this.showRetransmitQR(retransmitRequest, scanner);
            }

            // Show QR code for retransmission request
            showRetransmitQR(request, scanner) {
                const modal = document.createElement('div');
                modal.id = 'retransmit-modal';
                modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 4000; display: flex; align-items: center; justify-content: center;';
                modal.innerHTML = `
                    <div style="background: white; padding: 20px; border-radius: 10px; max-width: 400px; text-align: center;">
                        <h3>⚠️ Data Error Detected</h3>
                        <p>Chunk ${request.seq + 1} was corrupted. Please ask the sender to resend it.</p>
                        <div id="retransmit-qr" style="margin: 20px 0;"></div>
                        <p style="font-size: 12px; color: #666;">Show this QR to the sender device</p>
                        <button onclick="this.closest('#retransmit-modal').remove(); chunkedTransfer.resumeScanning('${scanner}');" class="submit-button">
                            Resume Scanning
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);

                new QRCode(document.getElementById('retransmit-qr'), {
                    text: JSON.stringify(request),
                    width: 200,
                    height: 200,
                    correctLevel: QRCode.CorrectLevel.L
                });
            }

            // Resume scanning after retransmission request
            resumeScanning(scanner) {
                // Scanner is already running, just continue
            }

            // Send acknowledgment for successful chunk receipt
            sendAcknowledgment(seq, scanner) {
                const ackPacket = {
                    type: 'ack',
                    seq: seq,
                    timestamp: Date.now()
                };

                // Show acknowledgment QR briefly
                this.showAckQR(ackPacket, scanner);
            }

            // Show acknowledgment QR
            showAckQR(ack, scanner) {
                const existingAck = document.getElementById('ack-modal');
                if (existingAck) existingAck.remove();

                const modal = document.createElement('div');
                modal.id = 'ack-modal';
                modal.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 10px; border-radius: 5px; z-index: 3001;';
                modal.innerHTML = `
                    <div>✅ Chunk ${ack.seq + 1} received successfully</div>
                `;
                document.body.appendChild(modal);

                // Auto-remove after 2 seconds
                setTimeout(() => modal.remove(), 2000);
            }

            // Handle retransmission request (sender side)
            handleRetransmitRequest(request, scanner) {
                console.log(`Retransmission requested for chunk ${request.seq}`);
                this.retransmissionRequests.add(request.seq);

                // Jump to the requested chunk
                this.currentChunk = request.seq;
                this.showCurrentChunk();

                // Show retransmission notification
                this.showRetransmitNotification(request.seq);
            }

            // Show retransmission notification
            showRetransmitNotification(seq) {
                const notification = document.createElement('div');
                notification.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #FF9800; color: white; padding: 10px 20px; border-radius: 5px; z-index: 3001;';
                notification.innerHTML = `🔄 Retransmitting chunk ${seq + 1}...`;
                document.body.appendChild(notification);

                setTimeout(() => notification.remove(), 3000);
            }

            // Handle acknowledgment (sender side)
            handleAcknowledgment(ack, scanner) {
                console.log(`Acknowledgment received for chunk ${ack.seq}`);
                this.ackPackets[ack.seq] = true;

                // Show acknowledgment notification
                const notification = document.createElement('div');
                notification.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #4CAF50; color: white; padding: 10px 20px; border-radius: 5px; z-index: 3001;';
                notification.innerHTML = `✅ Chunk ${ack.seq + 1} acknowledged`;
                document.body.appendChild(notification);

                setTimeout(() => notification.remove(), 2000);
            }

            assembleAndImport(username) {
                try {
                    // Reassemble in order
                    let fullData = '';
                    for (let i = 0; i < this.expectedChunks; i++) {
                        fullData += this.scannedChunks[i];
                    }

                    // Try to decompress first, fall back to original format
                    let decoded = decompressData(fullData);
                    if (!decoded) {
                        decoded = JSON.parse(atob(fullData));
                    }
                    const imported = {
                        users: {
                            [username]: {
                                answers: decoded.answers,
                                reasons: decoded.reasons,
                                timestamps: decoded.timestamps,
                                attempts: decoded.attempts || {}
                            }
                        }
                    };

                    mergeClassData(imported);

                    // Success!
                    document.getElementById('chunk-progress').innerHTML =
                        `✅ Success! Imported data from ${username}`;

                    setTimeout(() => {
                        this.cancelReceive();
                        loadProgress();
                    }, 2000);

                } catch(e) {
                    console.error('Error assembling chunks:', e);
                    document.getElementById('chunk-progress').innerHTML =
                        '❌ Error assembling data. Please try again.';
                }
            }

            cancelReceive() {
                // Stop any running camera
                try {
                    if (this.currentScanner) {
                        this.currentScanner.stop();
                    }
                } catch(e) {
                    console.error('Error stopping scanner:', e);
                }

                const modal = document.getElementById('chunked-receive');
                if (modal) modal.remove();
                this.scannedChunks = {};
                this.currentScanner = null;
            }
        }

        // Initialize chunked transfer
        const chunkedTransfer = new ChunkedQRTransfer();

        // Add buttons to sync controls
        window.showChunkedSend = function() {
            chunkedTransfer.showChunkedTransfer();
        }

        window.showChunkedReceive = function() {
            chunkedTransfer.startChunkedReceive();
        }

        // Add this diagnostic function to see what's happening:
        window.debugLoadCurriculum = async function() {
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;

            if (!files || files.length === 0) {
                console.log('No files selected');
                return;
            }

            console.log(`Loading ${files.length} file(s)...`);

            for (let file of files) {
                console.log(`\nProcessing file: ${file.name}`);
                const reader = new FileReader();

                await new Promise((resolve) => {
                    reader.onload = function(e) {
                        try {
                            const data = JSON.parse(e.target.result);
                            const questions = Array.isArray(data) ? data : (data.questions || []);

                            console.log(`Total questions in file: ${questions.length}`);

                            // Count questions by unit
                            const unitCounts = {};
                            questions.forEach(q => {
                                const match = q.id.match(/U(\d+)/i);
                                if (match) {
                                    const unit = match[1];
                                    unitCounts[unit] = (unitCounts[unit] || 0) + 1;
                                }
                            });

                            console.log('Questions by unit:', unitCounts);

                            // Show first few question IDs from each unit
                            Object.keys(unitCounts).forEach(unit => {
                                const unitQuestions = questions.filter(q => q.id.match(new RegExp(`U${unit}`, 'i')));
                                console.log(`Unit ${unit} first 3 IDs:`, unitQuestions.slice(0, 3).map(q => q.id));
                            });

                        } catch (error) {
                            console.error(`Error parsing ${file.name}:`, error);
                        }
                        resolve();
                    };
                    reader.readAsText(file);
                });
            }
        }

        // Fixed loadEntireCurriculum that handles mixed units in a single file:
        window.loadEntireCurriculum = async function() {
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;

            if (!files || files.length === 0) {
                showMessage('Please select curriculum JSON files', 'error');
                return;
            }

            allCurriculumData = {};
            let allQuestions = [];

            // First, load all questions from all files
            for (let file of files) {
                const reader = new FileReader();

                await new Promise((resolve, reject) => {
                    reader.onload = function(e) {
                        try {
                            const data = JSON.parse(e.target.result);
                            const questions = Array.isArray(data) ? data : (data.questions || []);
                            allQuestions = allQuestions.concat(questions);
                        } catch (error) {
                            console.error(`Error parsing ${file.name}:`, error);
                        }
                        resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            console.log(`Loaded ${allQuestions.length} total questions`);

            // Now group questions by unit
            const unitGroups = {};
            allQuestions.forEach(question => {
                const unitMatch = question.id.match(/U(\d+)/i);
                if (unitMatch) {
                    const unitNum = parseInt(unitMatch[1]);
                    if (!unitGroups[unitNum]) {
                        unitGroups[unitNum] = [];
                    }
                    unitGroups[unitNum].push(question);
                }
            });

            console.log('Found units:', Object.keys(unitGroups));

            // Process each unit group
            Object.keys(unitGroups).forEach(unitNum => {
                const unitQuestions = unitGroups[unitNum];
                const unitInfo = detectUnitAndLessons(unitQuestions);

                if (unitInfo) {
                    allCurriculumData[unitNum] = {
                        questions: unitQuestions,
                        unitInfo: unitInfo,
                        fileName: `Unit ${unitNum}`
                    };
                    console.log(`Unit ${unitNum}: ${unitQuestions.length} questions, ${unitInfo.lessonNumbers.length} lessons`);
                }
            });

            const loadedCount = Object.keys(allCurriculumData).length;
            if (loadedCount > 0) {
                showMessage(`Loaded ${loadedCount} units with ${allQuestions.length} total questions!`, 'success');
                renderUnitMenu();
            } else {
                showMessage('No valid units found in files', 'error');
            }
        }

        // New function to render unit selection menu
        function renderUnitMenu() {
            const questionsContainer = document.getElementById('questionsContainer');

            // Sort units numerically
            const sortedUnits = Object.keys(allCurriculumData).sort((a, b) => parseInt(a) - parseInt(b));

            console.log('Rendering units:', sortedUnits); // Debug log

            let unitsHtml = '';
            sortedUnits.forEach(unitNum => {
                const unitData = allCurriculumData[unitNum];
                const unitName = unitStructure[unitNum]?.name || `Unit ${unitNum}`;
                const lessonCount = unitData.unitInfo.lessonNumbers.length;
                const questionCount = unitData.questions.length;

                console.log(`Unit ${unitNum}: ${questionCount} questions, ${lessonCount} lessons`); // Debug log

                // Calculate completion percentage for this unit
                let completedQuestions = 0;
                unitData.questions.forEach(q => {
                    if (isQuestionAnswered(q.id)) completedQuestions++;
                });
                const completionPercent = questionCount > 0 ? Math.round((completedQuestions / questionCount) * 100) : 0;

                unitsHtml += `
                    <div class="unit-card" onclick="selectUnit(${unitNum})">
                        <div class="unit-header">
                            <h3>Unit ${unitNum}</h3>
                            <span class="completion-badge">${completionPercent}%</span>
                        </div>
                        <div class="unit-title">${unitName}</div>
                        <div class="unit-stats">
                            <span>${lessonCount} lessons</span>
                            <span>•</span>
                            <span>${questionCount} questions</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${completionPercent}%"></div>
                        </div>
                    </div>
                `;
            });

            questionsContainer.innerHTML = `
                <div class="curriculum-overview">
                    <h2>📚 AP Statistics Curriculum</h2>
                    <p style="text-align: center; color: #666;">Loaded ${sortedUnits.length} units</p>

                    <div class="units-grid">
                        ${unitsHtml}
                    </div>

                    <div class="app-controls" style="margin-top: 20px;">
                        ${renderSyncButtons()}
                    </div>

                    <!-- QR Code Section (Initially Hidden) -->
                    <div style="margin: 20px auto; text-align: center;">
                        <button onclick="toggleSiteQR()" class="sync-button" style="background: #607D8B;">
                            📱 Show Site QR Code
                        </button>
                        <div id="site-qr-container" style="display: none; margin: 20px auto; padding: 20px; background: #f0f7ff; border: 2px solid #3498db; border-radius: 10px; max-width: 400px;">
                            <div id="site-qr" style="margin: 15px auto;"></div>
                            <p style="margin: 10px 0 0 0; font-size: 14px; color: #666;">
                                Scan to open this site on mobile device
                            </p>
                        </div>
                    </div>
                </div>
            `;

        }

        // Function to select a unit
        window.selectUnit = function(unitNumber) {
            currentUnit = unitNumber;
            const unitData = allCurriculumData[unitNumber];
            allUnitQuestions = unitData.questions;

            // Render lesson selector for this unit
            renderLessonSelector(unitData.unitInfo);
        }

        // Modify backToUnits function to go back to unit menu instead
        window.backToUnits = function() {
            // Clear any existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};
            currentQuestions = [];
            currentUnit = null;
            currentLesson = null;

            // Show unit menu instead of file upload
            renderUnitMenu();
        }

        // Update the file upload interface to accept multiple files
        function renderFileUpload() {
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <h2>Load Curriculum Files</h2>
                    <p style="margin-bottom: 20px;">Select all unit JSON files (you can select multiple)</p>
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <input type="file" id="fileInput" accept=".json" multiple
                               style="padding: 10px; font-size: 16px;">
                    </div>
                    <button onclick="loadEntireCurriculum()" class="submit-button" style="padding: 12px 30px;">
                        Load Entire Curriculum
                    </button>
                    <div style="margin-top: 30px; padding: 15px; background: #e3f2fd; border-radius: 8px;">
                        <strong>Tip:</strong> Hold Ctrl (or Cmd on Mac) while clicking to select multiple unit files at once.
                    </div>
                </div>
            `;
        }

        // Enhanced function to load resources from allUnitsData.js if it exists
        async function loadUnitResources() {
            try {
                // Check if ALL_UNITS_DATA exists (from allUnitsData.js or dynamic loading)
                if (typeof ALL_UNITS_DATA !== 'undefined' && ALL_UNITS_DATA.length > 0) {
                    console.log('Found ALL_UNITS_DATA, integrating resources...');
                    return ALL_UNITS_DATA;
                }

                // Check if resources are currently being loaded by loadCurriculumResources
                if (document.querySelector('script[src="allUnitsData.js"]')) {
                    console.log('ALL_UNITS_DATA is being loaded dynamically, waiting...');
                    // Wait for the script to load
                    return new Promise((resolve) => {
                        const checkInterval = setInterval(() => {
                            if (typeof ALL_UNITS_DATA !== 'undefined') {
                                clearInterval(checkInterval);
                                console.log('ALL_UNITS_DATA loaded from dynamic loading');
                                resolve(ALL_UNITS_DATA);
                            }
                        }, 100);
                        // Timeout after 5 seconds
                        setTimeout(() => {
                            clearInterval(checkInterval);
                            console.log('Timeout waiting for ALL_UNITS_DATA');
                            resolve(null);
                        }, 5000);
                    });
                }

                // Try to dynamically load the file if not already loaded
                const script = document.createElement('script');
                script.src = 'allUnitsData.js';

                return new Promise((resolve, reject) => {
                    script.onload = () => {
                        if (typeof ALL_UNITS_DATA !== 'undefined') {
                            console.log('Loaded ALL_UNITS_DATA from file');
                            resolve(ALL_UNITS_DATA);
                        } else {
                            resolve(null);
                        }
                    };
                    script.onerror = () => resolve(null);
                    document.head.appendChild(script);
                });
            } catch (error) {
                console.log('No resources file found');
                return null;
            }
        }

        // Modified renderLessonSelector to show video resources
        async function renderLessonSelectorWithResources(unitInfo) {
            const questionsContainer = document.getElementById('questionsContainer');

            // Load resources if available
            const resources = await loadUnitResources();
            const unitResources = resources ?
                resources.find(u => u.unitId === `unit${currentUnit}`) : null;

            let lessonButtonsHtml = '';

            if (unitInfo && unitInfo.lessonNumbers) {
                unitInfo.lessonNumbers.forEach(lessonNum => {
                    const questions = unitInfo.lessons[lessonNum];
                    const isCompleted = questions.every(q => isQuestionAnswered(q.id));
                    const displayName = lessonNum === 'PC' ? 'Progress Check' : `Lesson ${lessonNum}`;
                    const buttonId = lessonNum === 'PC' ? 'lesson-btn-PC' : `lesson-btn-${lessonNum}`;

                    // Find matching resources for this lesson
                    let resourceInfo = '';
                    if (unitResources && lessonNum !== 'PC') {
                        const topicId = `${currentUnit}-${lessonNum}`;
                        const topic = unitResources.topics.find(t => t.id === topicId);
                        if (topic && topic.videos && topic.videos.length > 0) {
                            resourceInfo = `<span style="color: #4CAF50;">📹 ${topic.videos.length} video${topic.videos.length > 1 ? 's' : ''}</span>`;
                        }
                    }

                    lessonButtonsHtml += `
                        <button onclick="loadLesson('${lessonNum}')"
                                class="lesson-btn ${isCompleted ? 'completed' : ''}"
                                id="${buttonId}">
                            ${displayName}<br>
                            <small>${questions.length} questions</small>
                            ${resourceInfo ? `<br><small>${resourceInfo}</small>` : ''}
                        </button>
                    `;
                });

                questionsContainer.innerHTML = `
                    <button onclick="backToUnits()" class="back-button">← Back to Units</button>
                    <div class="lesson-selector">
                        <h3>Unit ${currentUnit}: ${unitStructure[currentUnit]?.name || 'Unknown Unit'}</h3>
                        <p>Select a lesson to begin:</p>
                        <div class="lesson-buttons">
                            ${lessonButtonsHtml}
                        </div>
                    </div>
                    <div class="app-controls">
                        ${renderSyncButtons()}
                    </div>
                `;
            }
        }

        // Modified loadLesson to show video resources at the top
        window.loadLessonWithResources = async function(lessonNumber) {
            currentLesson = lessonNumber;

            // Get questions for this lesson
            if (lessonNumber === 'PC') {
                currentQuestions = allUnitQuestions.filter(q => q.id.includes('-PC-'));
            } else {
                const lessonNum = parseInt(lessonNumber);
                currentQuestions = allUnitQuestions.filter(q => {
                    if (q.id.includes('-PC-')) return false;
                    const match = q.id.match(/U\d+-L(\d+)-/);
                    return match && parseInt(match[1]) === lessonNum;
                });
            }

            if (currentQuestions.length === 0) {
                showMessage(`No questions found for Lesson ${lessonNumber}`, 'error');
                return;
            }

            // Get resources for this lesson
            const resources = await loadUnitResources();
            let videoSection = '';

            if (resources && lessonNumber !== 'PC') {
                const unitResources = resources.find(u => u.unitId === `unit${currentUnit}`);
                if (unitResources) {
                    const topicId = `${currentUnit}-${lessonNumber}`;
                    const topic = unitResources.topics.find(t => t.id === topicId);

                    if (topic) {
                        videoSection = `
                            <div class="resources-section">
                                <h3>📚 Lesson Resources: ${topic.description}</h3>
                        `;

                        if (topic.videos && topic.videos.length > 0) {
                            videoSection += '<div class="video-resources">';
                            topic.videos.forEach((video, index) => {
                                videoSection += `
                                    <div class="video-item">
                                        <span class="video-number">Video ${index + 1}:</span>
                                        <a href="${video.url}" target="_blank" class="video-link">
                                            AP Classroom Video 📹
                                        </a>
                                        ${video.altUrl ? `
                                            <a href="${video.altUrl}" target="_blank" class="video-link alt">
                                                Alternative Link 🔗
                                            </a>
                                        ` : ''}
                                    </div>
                                `;
                            });
                            videoSection += '</div>';
                        }

                        videoSection += '</div>';
                    }
                }
            }

            // Render quiz with resources
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = `
                <button onclick="backToLessons()" class="back-button">← Back to Lessons</button>
                <div class="app-controls">
                    <div style="flex: 1;">
                        <strong>Unit ${currentUnit}, Lesson ${currentLesson}</strong> - ${currentQuestions.length} questions
                    </div>
                    ${renderSyncButtons()}
                </div>
                ${videoSection}
                <div id="questions-list"></div>
                <div class="loading-msg" id="loading-msg" style="display:none;">Loading questions...</div>
            `;

            const questionsList = document.getElementById('questions-list');
            document.getElementById('loading-msg').style.display = 'block';

            setTimeout(() => {
                currentQuestions.forEach((question, index) => {
                    const questionHtml = renderQuestion(question, index);
                    questionsList.insertAdjacentHTML('beforeend', questionHtml);
                });

                document.getElementById('loading-msg').style.display = 'none';
                loadProgress();

                if (window.MathJax) {
                    MathJax.typesetPromise().catch(e => console.log('MathJax error:', e));
                }

                setTimeout(renderVisibleCharts, 100);
            }, 100);
        }

        // Add styles for the resources section
        const resourceStyles = `
        .resources-section {
            background: #f0f7ff;
            border: 2px solid #2196F3;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .resources-section h3 {
            margin-top: 0;
            color: #1976D2;
        }

        .video-resources {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 15px;
        }

        .video-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .video-number {
            font-weight: bold;
            color: #666;
            min-width: 70px;
        }

        .video-link {
            padding: 6px 12px;
            background: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.3s;
        }

        .video-link:hover {
            background: #45a049;
        }

        .video-link.alt {
            background: #ff9800;
        }

        .video-link.alt:hover {
            background: #f57c00;
        }

        body.dark-theme .resources-section {
            background: #1e3a5f;
            border-color: #5BC0EB;
        }

        body.dark-theme .resources-section h3 {
            color: #5BC0EB;
        }

        body.dark-theme .video-item {
            background: #2d2d2d;
            border-color: #444;
        }
        `;

        // Add the styles
        document.head.insertAdjacentHTML('beforeend', `<style>${resourceStyles}</style>`);

        // Update the original functions to use the resource-aware versions
        window.renderLessonSelector = renderLessonSelectorWithResources;
        window.loadLesson = loadLessonWithResources;

        // Replace your existing sync button functions with this:
        window.startHandshakeSync = function() {
            if (!qrSync) {
                qrSync = new QRSyncManager();
            }
            qrSync.initiateSyncSession();
        }

        // Add this button when on mobile or in master mode
        function renderMasterSync() {
            return `
                <div class="master-sync-container">
                    <button onclick="startMasterSync()" class="sync-button" style="background: #9C27B0;">
                        👑 Master Sync Mode
                    </button>
                    <div id="sync-status"></div>
                </div>
            `;
        }

        window.startMasterSync = function() {
            let scannedStudents = [];

            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 3000; padding: 20px; overflow-y: auto;';
            modal.innerHTML = `
                <div style="max-width: 600px; margin: 0 auto;">
                    <h2>👑 Master Sync Mode</h2>
                    <p>Scan each student's QR code. The camera will stay active.</p>

                    <div id="qr-reader" style="width: 100%;"></div>

                    <div style="margin: 20px 0; padding: 15px; background: #f0f0f0; border-radius: 8px;">
                        <h3>Scanned Students (<span id="scan-count">0</span>)</h3>
                        <div id="scanned-list"></div>
                    </div>

                    <button onclick="finishMasterSync()" class="submit-button" style="background: #4CAF50;">
                        Finish & Export Merged Data
                    </button>
                    <button onclick="cancelMasterSync()" class="submit-button" style="background: #f44336; margin-left: 10px;">
                        Cancel
                    </button>
                </div>
            `;
            document.body.appendChild(modal);

            // Start scanner
            const html5QrCode = new Html5Qrcode("qr-reader");
            window.currentScanner = html5QrCode;
            window.scannedStudents = scannedStudents;

            html5QrCode.start(
                { facingMode: "environment" },
                { fps: 10, qrbox: { width: 250, height: 250 } },
                (decodedText) => {
                    try {
                        // Try decompression first, fall back to original format
                        let data = decompressData(decodedText);
                        if (!data) {
                            data = JSON.parse(atob(decodedText));
                        }
                        if (data.username && !scannedStudents.find(s => s.username === data.username)) {
                            scannedStudents.push(data);

                            // Update UI
                            document.getElementById('scan-count').textContent = scannedStudents.length;
                            document.getElementById('scanned-list').innerHTML +=
                                `<div>✓ ${data.username} - ${Object.keys(data.changes || {}).length} answers</div>`;

                            // Brief success sound/vibration if available
                            if (navigator.vibrate) navigator.vibrate(200);
                        }
                    } catch(e) {
                        console.error('Invalid QR:', e);
                    }
                }
            ).catch(err => {
                alert('Camera error: ' + err);
            });
        }

        window.finishMasterSync = function() {
    if (window.currentScanner) {
        window.currentScanner.stop();
    }

    // Merge all scanned data
    window.scannedStudents.forEach(studentData => {
        const imported = {
            users: {
                [studentData.username]: studentData.changes || studentData.data
            }
        };
        mergeClassData(imported);
    });

    // Just save to local storage, don't export
    saveClassData();

    document.querySelector('[style*="position: fixed"]').remove();
    showMessage(`Merged ${window.scannedStudents.length} students' data!`, 'success');

    // Refresh the current view to show new data
    loadProgress();
}

        window.cancelMasterSync = function() {
            if (window.currentScanner) {
                window.currentScanner.stop();
            }
            document.querySelector('[style*="position: fixed"]').remove();
        }

        window.toggleSiteQR = function() {
            const container = document.getElementById('site-qr-container');
            const button = event.target;

            if (container.style.display === 'none') {
                container.style.display = 'block';
                button.textContent = '📱 Hide Site QR Code';

                // Generate QR if not already done
                const qrElement = document.getElementById('site-qr');
                if (qrElement && !qrElement.hasChildNodes()) {
                    // Include username in URL
                    const baseUrl = 'https://robjohncolson.github.io/test_curriculum_render/';
                    const urlWithUser = currentUsername ?
                        `${baseUrl}?user=${encodeURIComponent(currentUsername)}` :
                        baseUrl;

                    new QRCode(qrElement, {
                        text: urlWithUser,
                        width: 200,
                        height: 200,
                        correctLevel: QRCode.CorrectLevel.L
                    });
                }
            } else {
                container.style.display = 'none';
                button.textContent = '📱 Show Site QR Code';
            }
        }

        // Smart Bidirectional Sync with Negotiation
        class SmartSync {
            constructor() {
                this.syncSession = null;
                this.role = null; // 'initiator' or 'responder'
                this.peerManifest = null;
                this.myManifest = null;
                this.syncPlan = null;
            }

            // Generate manifest of what we have
            generateManifest() {
                const manifest = {
                    deviceId: getDeviceId(),
                    username: currentUsername,
                    timestamp: Date.now(),
                    questions: {}
                };

                // List all questions we have with their timestamps
                for (let user in classData.users) {
                    manifest.questions[user] = {};
                    const userData = classData.users[user];

                    for (let qId in userData.answers) {
                        manifest.questions[user][qId] = {
                            timestamp: userData.timestamps?.[qId] || 0,
                            version: userData.answers[qId]?.version || 1
                        };
                    }
                }

                return manifest;
            }

            // Start sync as initiator
            initiate() {
                this.role = 'initiator';
                this.myManifest = this.generateManifest();

                const modal = document.createElement('div');
                modal.id = 'smart-sync-modal';
                modal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 3000; padding: 20px;';
                modal.innerHTML = `
                    <div style="max-width: 600px; margin: 0 auto;">
                        <h2>🔄 Smart Sync - Step 1: Exchange Manifests</h2>

                        <div style="display: flex; gap: 20px; margin: 20px 0;">
                            <div style="flex: 1; text-align: center;">
                                <h3>Your Manifest</h3>
                                <div id="manifest-qr" style="margin: 10px auto;"></div>
                                <small>Show this to peer device</small>
                            </div>

                            <div style="flex: 1; text-align: center;">
                                <h3>Scan Peer's Manifest</h3>
                                <div id="manifest-scanner" style="height: 256px; border: 2px dashed #ccc;"></div>
                                <small>Point at their manifest QR</small>
                            </div>
                        </div>

                        <div id="sync-status" style="padding: 15px; background: #f0f0f0; border-radius: 5px;">
                            Waiting for peer manifest...
                        </div>

                        <button onclick="smartSync.cancel()" class="submit-button" style="background: #f44336;">
                            Cancel
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);

                // Show our manifest as QR
                this.showManifestQR();

                // Start scanning for peer manifest
                this.scanForManifest();
            }

            showManifestQR() {
                // Compress manifest to fit in QR
                const compressedManifest = {
                    d: this.myManifest.deviceId.substr(-8), // Last 8 chars of device ID
                    u: this.myManifest.username,
                    t: this.myManifest.timestamp,
                    q: {} // Compressed question list
                };

                // Just send counts and latest timestamp per user
                for (let user in this.myManifest.questions) {
                    const userQuestions = this.myManifest.questions[user];
                    const timestamps = Object.values(userQuestions).map(q => q.timestamp);
                    compressedManifest.q[user] = {
                        c: Object.keys(userQuestions).length, // count
                        l: Math.max(...timestamps, 0) // latest timestamp
                    };
                }

                new QRCode(document.getElementById('manifest-qr'), {
                    text: JSON.stringify(compressedManifest),
                    width: 256,
                    height: 256,
                    correctLevel: QRCode.CorrectLevel.L
                });
            }

            scanForManifest() {
                const html5QrCode = new Html5Qrcode("manifest-scanner");

                html5QrCode.start(
                    { facingMode: "environment" },
                    { fps: 10, qrbox: { width: 200, height: 200 } },
                    (decodedText) => {
                        try {
                            const manifest = JSON.parse(decodedText);
                            if (manifest.q) { // It's a manifest
                                this.receivePeerManifest(manifest);
                                html5QrCode.stop();
                            }
                        } catch(e) {
                            console.error('Invalid manifest:', e);
                        }
                    }
                ).catch(err => {
                    console.error('Scanner error:', err);
                });
            }

            receivePeerManifest(manifest) {
                this.peerManifest = manifest;

                // Analyze what needs syncing
                const syncPlan = this.createSyncPlan();

                document.getElementById('sync-status').innerHTML = `
                    <h3>📊 Sync Plan</h3>
                    <div>Peer: ${manifest.u}</div>
                    <div>You need: ${syncPlan.toReceive.length} updates</div>
                    <div>They need: ${syncPlan.toSend.length} updates</div>
                    <button onclick="smartSync.executeSyncPlan()" class="submit-button" style="margin-top: 10px;">
                        Execute Sync
                    </button>
                `;

                this.syncPlan = syncPlan;
            }

            createSyncPlan() {
                const toSend = [];
                const toReceive = [];

                // Check what peer has that we don't (or is newer)
                for (let user in this.peerManifest.q) {
                    const peerLatest = this.peerManifest.q[user].l;
                    const myLatest = this.getLatestTimestamp(user);

                    if (peerLatest > myLatest) {
                        toReceive.push({
                            user: user,
                            after: myLatest // We want everything after this timestamp
                        });
                    }
                }

                // Check what we have that peer doesn't (or is newer)
                for (let user in this.myManifest.questions) {
                    const myLatest = this.getLatestTimestamp(user);
                    const peerLatest = this.peerManifest.q[user]?.l || 0;

                    if (myLatest > peerLatest) {
                        toSend.push({
                            user: user,
                            after: peerLatest // Send everything after this timestamp
                        });
                    }
                }

                return { toSend, toReceive };
            }

            getLatestTimestamp(username) {
                const userQuestions = this.myManifest.questions[username];
                if (!userQuestions) return 0;
                const timestamps = Object.values(userQuestions).map(q => q.timestamp);
                return Math.max(...timestamps, 0);
            }

            executeSyncPlan() {
                // Update UI
                document.getElementById('smart-sync-modal').innerHTML = `
                    <div style="max-width: 600px; margin: 0 auto;">
                        <h2>🔄 Smart Sync - Step 2: Exchange Data</h2>

                        <div id="sync-progress" style="margin: 20px 0;">
                            <h3>Sending Your Updates...</h3>
                            <div id="send-progress"></div>

                            <h3 style="margin-top: 20px;">Receiving Their Updates...</h3>
                            <div id="receive-progress"></div>
                        </div>

                        <div style="display: flex; gap: 20px; margin: 20px 0;">
                            <div style="flex: 1;">
                                <div id="data-qr" style="margin: 10px auto;"></div>
                                <div id="send-status" style="text-align: center;">Preparing...</div>
                            </div>

                            <div style="flex: 1;">
                                <div id="data-scanner" style="height: 256px;"></div>
                                <div id="receive-status" style="text-align: center;">Ready to scan...</div>
                            </div>
                        </div>

                        <button onclick="smartSync.cancel()" class="submit-button" style="background: #f44336;">
                            Cancel
                        </button>
                    </div>
                `;

                // Start sending our data
                this.sendData();

                // Start receiving their data
                this.receiveData();
            }

            sendData() {
                const dataToSend = {};

                // Collect data based on sync plan
                this.syncPlan.toSend.forEach(item => {
                    const userData = classData.users[item.user];
                    if (!userData) return;

                    dataToSend[item.user] = {};

                    for (let qId in userData.answers) {
                        const timestamp = userData.timestamps?.[qId] || 0;
                        if (timestamp > item.after) {
                            dataToSend[item.user][qId] = {
                                answer: userData.answers[qId],
                                reason: userData.reasons?.[qId],
                                timestamp: timestamp,
                                attempts: userData.attempts?.[qId]
                            };
                        }
                    }
                });

                // Show as QR (might need chunking for large data)
                const packet = {
                    type: 'sync-data',
                    from: currentUsername,
                    data: dataToSend,
                    timestamp: Date.now()
                };

                const json = JSON.stringify(packet);

                if (json.length > 2000) {
                    document.getElementById('send-status').textContent =
                        'Data too large - using chunked transfer...';
                    this.startChunkedSend(json);
                } else {
                    new QRCode(document.getElementById('data-qr'), {
                        text: json,
                        width: 256,
                        height: 256,
                        correctLevel: QRCode.CorrectLevel.L
                    });
                    document.getElementById('send-status').textContent = 'Ready - show to peer';
                }
            }

            receiveData() {
                const html5QrCode = new Html5Qrcode("data-scanner");

                html5QrCode.start(
                    { facingMode: "environment" },
                    { fps: 10, qrbox: { width: 200, height: 200 } },
                    (decodedText) => {
                        try {
                            const packet = JSON.parse(decodedText);
                            if (packet.type === 'sync-data') {
                                this.importReceivedData(packet.data);
                                html5QrCode.stop();
                                document.getElementById('receive-status').textContent =
                                    '✅ Data received!';
                            }
                        } catch(e) {
                            console.error('Invalid data:', e);
                        }
                    }
                );
            }

            importReceivedData(data) {
                // Merge the received data
                for (let username in data) {
                    if (!classData.users[username]) {
                        classData.users[username] = {
                            answers: {},
                            reasons: {},
                            timestamps: {},
                            attempts: {}
                        };
                    }

                    const userData = data[username];
                    for (let qId in userData) {
                        const item = userData[qId];

                        // Only import if newer than what we have
                        const existingTimestamp = classData.users[username].timestamps?.[qId] || 0;
                        if (item.timestamp > existingTimestamp) {
                            classData.users[username].answers[qId] = item.answer;
                            classData.users[username].reasons[qId] = item.reason;
                            classData.users[username].timestamps[qId] = item.timestamp;
                            classData.users[username].attempts[qId] = item.attempts;
                        }
                    }
                }

                saveClassData();

                // Show completion
                setTimeout(() => {
                    document.getElementById('smart-sync-modal').innerHTML = `
                        <div style="max-width: 400px; margin: 100px auto; text-align: center;">
                            <h2>✅ Sync Complete!</h2>
                            <p>Both devices now have the same data</p>
                            <button onclick="smartSync.finish()" class="submit-button" style="margin-top: 20px;">
                                Done
                            </button>
                        </div>
                    `;
                }, 1000);
            }

            startChunkedSend(data) {
                // Implementation for chunked transfer when data is too large
                // Similar to the ChunkedQRTransfer class but integrated here
                alert('Chunked transfer not implemented yet. Please use smaller datasets or file export.');
                document.getElementById('send-status').textContent = '❌ Data too large for QR';
            }

            cancel() {
                document.getElementById('smart-sync-modal')?.remove();
            }

            finish() {
                this.cancel();
                loadProgress(); // Refresh the UI
            }
        }

        // Initialize
        const smartSync = new SmartSync();

        // Add button to start smart sync
        window.startSmartSync = function() {
            smartSync.initiate();
        }

        // Text Code Transfer System (No Camera Required on Desktop)
        class TextCodeTransfer {
            constructor() {
                this.activeCode = null;
                this.codeData = {};
            }

            // Desktop: Generate a 6-character code
            generateTransferCode() {
                // Create a simple 6-character code
                const code = Math.random().toString(36).substring(2, 8).toUpperCase();

                // Store the data associated with this code
                this.codeData[code] = {
                    username: currentUsername,
                    data: classData.users[currentUsername],
                    timestamp: Date.now(),
                    expires: Date.now() + (10 * 60 * 1000) // 10 minute expiry
                };

                this.activeCode = code;
                this.showCodeDisplay();

                // Clean up old codes
                this.cleanupExpiredCodes();

                return code;
            }

            showCodeDisplay() {
                const modal = document.createElement('div');
                modal.id = 'code-display';
                modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 2000; display: flex; align-items: center; justify-content: center;';
                modal.onclick = function(e) { if(e.target === modal) modal.remove(); };

                modal.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 10px; max-width: 400px; text-align: center;">
                        <h2>📤 Share Your Answers</h2>
                        <p>On your phone, enter this code:</p>

                        <div style="font-size: 48px; font-weight: bold; letter-spacing: 8px;
                                    background: #f0f0f0; padding: 20px; border-radius: 8px;
                                    margin: 20px 0; font-family: monospace;">
                            ${this.activeCode}
                        </div>

                        <div style="color: #666; font-size: 14px; margin-bottom: 20px;">
                            This code expires in 10 minutes
                        </div>

                        <button onclick="copyCodeToClipboard('${this.activeCode}')"
                                class="submit-button" style="margin-bottom: 10px;">
                            📋 Copy Code
                        </button>

                        <button onclick="this.closest('[style*=fixed]').remove()"
                                class="submit-button" style="background: #666;">
                            Done
                        </button>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            cleanupExpiredCodes() {
                const now = Date.now();
                for (let code in this.codeData) {
                    if (this.codeData[code].expires < now) {
                        delete this.codeData[code];
                    }
                }
            }
        }

        // Phone side - enter code and receive data
        window.enterTransferCode = function() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 2000; display: flex; align-items: center; justify-content: center;';
            modal.onclick = function(e) { if(e.target === modal) modal.remove(); };

            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 10px; max-width: 350px; width: 90%;">
                    <h2 style="text-align: center;">📥 Get Answers from Desktop</h2>
                    <p style="text-align: center;">Enter the 6-character code shown on the desktop:</p>

                    <input type="text"
                           id="transfer-code-input"
                           placeholder="ABC123"
                           maxlength="6"
                           style="width: 100%; padding: 15px; font-size: 24px; text-align: center;
                                  font-family: monospace; text-transform: uppercase;
                                  border: 2px solid #ddd; border-radius: 4px; margin: 20px 0;">

                    <div id="code-error" style="color: red; text-align: center; margin-bottom: 10px; display: none;">
                        Invalid or expired code
                    </div>

                    <button onclick="submitTransferCode()"
                            class="submit-button" style="width: 100%; margin-bottom: 10px;">
                        Get Data
                    </button>

                    <button onclick="this.closest('[style*=fixed]').remove()"
                            style="width: 100%; padding: 10px; background: none;
                                   border: 1px solid #ccc; border-radius: 4px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;

            document.body.appendChild(modal);

            // Auto-focus the input
            setTimeout(() => {
                document.getElementById('transfer-code-input').focus();
            }, 100);
        }

        window.submitTransferCode = function() {
            const input = document.getElementById('transfer-code-input');
            const code = input.value.toUpperCase();

            if (code.length !== 6) {
                document.getElementById('code-error').style.display = 'block';
                document.getElementById('code-error').textContent = 'Code must be 6 characters';
                return;
            }

            // Here you'd normally fetch from a server, but for local testing,
            // we'll use a workaround with localStorage as a shared medium
            const sharedData = localStorage.getItem(`transfer_${code}`);

            if (!sharedData) {
                document.getElementById('code-error').style.display = 'block';
                document.getElementById('code-error').textContent = 'Invalid or expired code';
                return;
            }

            try {
                const data = JSON.parse(sharedData);

                // Import the data
                const imported = {
                    users: {
                        [data.username]: data.data
                    }
                };
                mergeClassData(imported);

                // Clean up
                localStorage.removeItem(`transfer_${code}`);

                // Success message
                document.querySelector('[style*=fixed]').innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 10px; text-align: center;">
                        <h2>✅ Success!</h2>
                        <p>Imported answers from ${data.username}</p>
                        <button onclick="this.closest('[style*=fixed]').remove(); loadProgress();"
                                class="submit-button" style="margin-top: 20px;">
                            Done
                        </button>
                    </div>
                `;

            } catch(e) {
                document.getElementById('code-error').style.display = 'block';
                document.getElementById('code-error').textContent = 'Error processing data';
            }
        }

        // Helper function to copy code
        window.copyCodeToClipboard = function(code) {
            navigator.clipboard.writeText(code).then(() => {
                showMessage('Code copied to clipboard!', 'success');
            });
        }

        // Initialize
        const textTransfer = new TextCodeTransfer();

        // Desktop generates code and stores in localStorage (for local testing)
        window.shareViaCode = function() {
            const code = textTransfer.generateTransferCode();

            // For local testing, store in localStorage
            // In production, this would go to a server
            const dataPacket = {
                username: currentUsername,
                data: classData.users[currentUsername],
                timestamp: Date.now()
            };

            localStorage.setItem(`transfer_${code}`, JSON.stringify(dataPacket));

            // Auto-remove after 10 minutes
            setTimeout(() => {
                localStorage.removeItem(`transfer_${code}`);
            }, 10 * 60 * 1000);
        }

        // Audio Data Transfer System
        class AudioProtocol {
            constructor() {
                // FAST_CONFIG - Maximum speed optimization
                // PERFORMANCE IMPROVEMENTS ACHIEVED:
                // - Parallel Channels: 2x speedup (transmit on 2 frequency bands simultaneously)
                // - Hex Encoding: 4 bits per tone vs binary (4x speedup)
                // - Reduced Tone Duration: 10ms vs 100ms (10x speedup)
                // - Minimal Inter-symbol Delay: 5ms vs 50ms (10x speedup)
                // - Compression: Remove whitespace (1.2-1.5x speedup)
                // - Combined: ~8-10x total speedup
                // RESULT: 100 bytes in ~10 seconds instead of 88 seconds
                this.config = {
                    TONE_DURATION: 10,         // ms per symbol (10x faster than 100ms)
                    INTER_SYMBOL_DELAY: 5,     // ms between symbols (10x faster than 50ms)
                    SYMBOLS_PER_TONE: 4,       // bits per tone (16 frequencies)
                    ERROR_CORRECTION: false,   // Disable for speed
                    COMPRESSION: true,         // Enable compression
                    USE_HEX_ENCODING: true,    // 4 bits per tone (4x speedup)
                    SKIP_HANDSHAKE: false,     // Keep minimal handshake
                    PARALLEL_CHANNELS: 2       // Use 2 frequency bands (2x speedup)
                };

                this.audioContext = null;
                this.state = 'idle';
                this.role = null;

                // Same tones but adjusted timing
                this.tones = {
                    HELLO: 2000,
                    ACK: 2200,
                    READY: 2400,
                    DONE: 2600,
                    ERROR: 2800,
                    DATA_0: 3000,
                    DATA_1: 3200
                };

                // Parallel channel encoding: 2 frequency bands x 16 frequencies each = 32 frequencies for 5 bits at once (5x speedup)
                this.dataFrequencies = [];
                // Channel 1: 3000-4500 Hz (16 frequencies)
                for (let i = 0; i < 16; i++) {
                    this.dataFrequencies[i] = 3000 + (i * 100);
                }
                // Channel 2: 5000-6500 Hz (16 frequencies) - separated by guard band
                for (let i = 0; i < 16; i++) {
                    this.dataFrequencies[i + 16] = 5000 + (i * 100);
                }

                // Channel separation for parallel transmission
                this.channel1Freqs = this.dataFrequencies.slice(0, 16);
                this.channel2Freqs = this.dataFrequencies.slice(16, 32);

                // Adjusted timing parameters
                this.helloInterval = 3000;  // 3 seconds between HELLOs (was 2)
                this.listenWindowAfterTx = 1000;  // Listen for 1 second after transmitting

                // FFT Windowing configuration
                this.windowType = 'hamming'; // 'hamming', 'hann', 'blackman'
                this.detectionMode = 'hybrid'; // 'original', 'enhanced', 'hybrid'
                this.detectionStats = { enhanced: 0, original: 0, total: 0 };

                // Frequency Band Testing
                // Different frequencies work better in different environments
                this.frequencyBands = [
                    { start: 1000, end: 2000, name: 'low' },
                    { start: 2000, end: 4000, name: 'mid' },
                    { start: 4000, end: 8000, name: 'high' },
                    { start: 8000, end: 15000, name: 'ultrasonic' }
                ];

                // Speed profiles for adaptive transmission
                this.speedProfiles = {
                    'ultra-slow': { toneDuration: 200, interToneDelay: 100, name: 'Ultra Slow' },
                    'slow': { toneDuration: 100, interToneDelay: 50, name: 'Slow' },
                    'medium': { toneDuration: 50, interToneDelay: 25, name: 'Medium' },
                    'fast': { toneDuration: 20, interToneDelay: 10, name: 'Fast' },
                    'ultra-fast': { toneDuration: 10, interToneDelay: 5, name: 'Ultra Fast' }
                };

                this.currentSpeed = 'ultra-slow'; // Start with slowest
                this.speedTestResults = {};
                this.negotiatedSpeed = null;
            }

            init() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Fast handshake - skip slow back-and-forth
            async startHandshake() {
                if (!this.audioContext) this.init();

                this.role = 'initiator';
                this.state = 'handshaking';

                this.showHandshakeUI();

                // Start listening first
                await this.startListening();

                // Quick hello and immediate transmission
                await this.playTone(this.tones.HELLO, 100); // Quick hello
                await this.delay(50); // Very brief wait

                // Perform channel calibration before data transmission
                try {
                    this.updateStatus('🔧 Calibrating channel...');
                    await this.calibrateChannel();
                    this.updateStatus('✅ Calibration complete, starting transmission...');
                } catch (error) {
                    this.updateStatus(`⚠️ Calibration failed: ${error.message}, proceeding anyway...`);
                }

                // Start sending immediately with header
                this.transmitWithHeader();
            }

            async startAsSender() {
                if (!this.audioContext) this.init();

                this.role = 'sender';
                this.state = 'negotiating';

                this.showSenderUI();

                // Start listening for ACKs
                await this.startListening();

                // Negotiate speed with receiver
                await this.delay(1000); // Give receiver time to start

                const negotiatedSpeed = await this.negotiateSpeed();

                if (!negotiatedSpeed) {
                    this.updateStatus('❌ Could not establish connection');
                    setTimeout(() => this.cancel(), 3000);
                    return;
                }

                // Now send data at negotiated speed
                this.updateStatus(`📤 Sending data at ${this.speedProfiles[negotiatedSpeed].name} speed...`);
                await this.delay(500);

                await this.transmitDataReliable();
            }

            async startAsReceiver() {
                if (!this.audioContext) this.init();

                this.role = 'receiver';
                this.state = 'waiting_for_sender';

                this.showReceiverUI();
                await this.startListening();

                this.updateStatus('👂 Listening for sender...');
            }

            async transmitWithHeader() {
                // Send a header tone pattern - no delays
                await this.playTone(2000, 50);
                await this.playTone(2500, 50);
                await this.playTone(3000, 50);

                // Then send data immediately
                await this.transmitDataFast();
            }

            async sendHelloWithListening() {
                if (this.state !== 'handshaking') return;

                this.updateStatus('📡 Sending HELLO...');

                // Clear any existing timeout first
                clearTimeout(this.timeout);

                // Pause listening while transmitting
                this.pauseListening();
                await this.playTone(this.tones.HELLO, 100); // Reduced from 500ms for faster handshake

                // CRITICAL: Resume listening immediately
                this.resumeListening();
                this.updateStatus('👂 Listening for response...');

                // Set up next HELLO, but with a longer window for response
                this.timeout = setTimeout(() => {
                    if (this.state === 'handshaking') {
                        this.sendHelloWithListening(); // Retry only if still handshaking
                    }
                }, this.helloInterval);
            }

            // Responder side (phone usually)
            async respondToHandshake() {
                if (!this.audioContext) this.init();

                this.role = 'responder';
                this.state = 'listening_hello';

                this.showResponderUI();
                await this.startListening();
            }

            // Unified listening system
            async startListening() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                const source = this.audioContext.createMediaStreamSource(stream);
                const analyser = this.audioContext.createAnalyser();

                analyser.fftSize = 2048; // Reduced for faster processing while maintaining frequency resolution
                source.connect(analyser);

                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                this.isListening = true;
                this.currentStream = stream;
                this.dataBuffer = '';
                this.expectedLength = 0;
                this.analyser = analyser;
                this.dataArray = dataArray;

                this.listen = () => {
                    if (!this.isListening) return;

                    analyser.getByteFrequencyData(dataArray);

                    let tone = null;
                    this.detectionStats.total++;

                    if (this.detectionMode === 'enhanced' || this.detectionMode === 'hybrid') {
                        // Try enhanced detection first for data frequencies
                        const fastDetections = this.detectToneFast(dataArray, analyser.context.sampleRate, bufferLength);

                        if (fastDetections.length > 0) {
                            // Convert fast detection to tone format for compatibility
                            const bestDetection = fastDetections.reduce((best, current) =>
                                current.amplitude > best.amplitude ? current : best
                            );

                            // Map to existing tone format for data frequencies
                            if (bestDetection.value >= 0 && bestDetection.value < 16) {
                                tone = {
                                    name: `DATA_${bestDetection.value.toString(16).toUpperCase()}`,
                                    freq: bestDetection.frequency,
                                    strength: bestDetection.amplitude,
                                    hexValue: bestDetection.value,
                                    enhanced: true
                                };
                                this.detectionStats.enhanced++;
                            }
                        }
                    }

                    // Fall back to original detection for control tones and validation
                    if (!tone && (this.detectionMode === 'original' || this.detectionMode === 'hybrid')) {
                        tone = this.detectTone(dataArray, analyser.context.sampleRate, bufferLength);
                        if (tone) {
                            this.detectionStats.original++;
                        }
                    }

                    if (tone) {
                        this.handleTone(tone);
                    }

                    this.animationFrame = requestAnimationFrame(this.listen);
                };

                this.listen();
            }

            // FFT Windowing functions for improved detection
            createHammingWindow(size) {
                const window = new Float32Array(size);
                for (let i = 0; i < size; i++) {
                    window[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (size - 1));
                }
                return window;
            }

            createHannWindow(size) {
                const window = new Float32Array(size);
                for (let i = 0; i < size; i++) {
                    window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
                }
                return window;
            }

            createBlackmanWindow(size) {
                const window = new Float32Array(size);
                const a0 = 0.42;
                const a1 = 0.5;
                const a2 = 0.08;
                for (let i = 0; i < size; i++) {
                    window[i] = a0 - a1 * Math.cos(2 * Math.PI * i / (size - 1)) +
                               a2 * Math.cos(4 * Math.PI * i / (size - 1));
                }
                return window;
            }

            // Get the configured window function
            getWindowFunction(size) {
                switch (this.windowType) {
                    case 'hann':
                        return this.createHannWindow(size);
                    case 'blackman':
                        return this.createBlackmanWindow(size);
                    case 'hamming':
                    default:
                        return this.createHammingWindow(size);
                }
            }

            // Apply windowing to frequency data for better spectral analysis
            applyWindowToFFT(dataArray, window) {
                const windowed = new Uint8Array(dataArray.length);
                for (let i = 0; i < dataArray.length; i++) {
                    windowed[i] = dataArray[i] * window[i];
                }
                return windowed;
            }

            // Enhanced tone detection with FFT windowing and parallel channel support
            detectToneFast(dataArray, sampleRate, bufferLength) {
                const detected = [];

                // Apply configured window for better frequency resolution
                const window = this.getWindowFunction(bufferLength);
                const windowedData = this.applyWindowToFFT(dataArray, window);

                // Check data frequency bands with improved detection
                // Channel 1: 3000-4500 Hz range
                const channel1Freqs = [3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400];
                // Channel 2: 5000-6500 Hz range for parallel transmission
                const channel2Freqs = [5000, 5200, 5400, 5600, 5800, 6000, 6200, 6400];

                // Detect Channel 1 frequencies
                for (let baseFreq of channel1Freqs) {
                    let maxAmplitude = 0;
                    let bestOffset = 0;

                    // Check offsets in 20Hz steps for better resolution
                    for (let offset = -50; offset <= 50; offset += 20) {
                        const freq = baseFreq + offset;
                        if (freq < 0 || freq > sampleRate / 2) continue;

                        const bin = Math.round(freq * bufferLength * 2 / sampleRate);

                        if (bin >= 0 && bin < windowedData.length) {
                            // Use windowed data and check neighboring bins for robustness
                            const amplitude = (
                                windowedData[bin] +
                                (bin > 0 ? windowedData[bin - 1] : 0) +
                                (bin < windowedData.length - 1 ? windowedData[bin + 1] : 0)
                            ) / 3;

                            if (amplitude > maxAmplitude) {
                                maxAmplitude = amplitude;
                                bestOffset = offset;
                            }
                        }
                    }

                    // Lower threshold for windowed data (windowing reduces overall amplitude)
                    if (maxAmplitude > 80) {
                        detected.push({
                            channel: 1,
                            band: baseFreq,
                            offset: bestOffset,
                            value: Math.floor((baseFreq + bestOffset - 3000) / 100),
                            amplitude: maxAmplitude,
                            frequency: baseFreq + bestOffset
                        });
                    }
                }

                // Detect Channel 2 frequencies
                for (let baseFreq of channel2Freqs) {
                    let maxAmplitude = 0;
                    let bestOffset = 0;

                    // Check offsets in 20Hz steps for better resolution
                    for (let offset = -50; offset <= 50; offset += 20) {
                        const freq = baseFreq + offset;
                        if (freq < 0 || freq > sampleRate / 2) continue;

                        const bin = Math.round(freq * bufferLength * 2 / sampleRate);

                        if (bin >= 0 && bin < windowedData.length) {
                            // Use windowed data and check neighboring bins for robustness
                            const amplitude = (
                                windowedData[bin] +
                                (bin > 0 ? windowedData[bin - 1] : 0) +
                                (bin < windowedData.length - 1 ? windowedData[bin + 1] : 0)
                            ) / 3;

                            if (amplitude > maxAmplitude) {
                                maxAmplitude = amplitude;
                                bestOffset = offset;
                            }
                        }
                    }

                    // Lower threshold for windowed data (windowing reduces overall amplitude)
                    if (maxAmplitude > 80) {
                        detected.push({
                            channel: 2,
                            band: baseFreq,
                            offset: bestOffset,
                            value: Math.floor((baseFreq + bestOffset - 5000) / 100),
                            amplitude: maxAmplitude,
                            frequency: baseFreq + bestOffset
                        });
                    }
                }

                return detected;
            }

            // Add visual feedback for audio detection
            detectTone(dataArray, sampleRate, bufferLength) {
                let detectedTone = null;
                let maxStrength = 0;

                // Check standard tones first
                for (let [name, freq] of Object.entries(this.tones)) {
                    const bin = Math.round(freq * bufferLength * 2 / sampleRate);
                    const strength = (dataArray[bin] + dataArray[bin-1] + dataArray[bin+1]) / 3;

                    if (strength > 120 && strength > maxStrength) {
                        maxStrength = strength;
                        detectedTone = { name, freq, strength };
                    }
                }

                // Check data frequencies (3000-4500 Hz range)
                for (let i = 0; i < this.dataFrequencies.length; i++) {
                    const freq = this.dataFrequencies[i];
                    const bin = Math.round(freq * bufferLength * 2 / sampleRate);
                    const strength = (dataArray[bin] + dataArray[bin-1] + dataArray[bin+1]) / 3;

                    if (strength > 120 && strength > maxStrength) {
                        maxStrength = strength;
                        detectedTone = { name: `DATA_${i.toString(16).toUpperCase()}`, freq, strength, hexValue: i };
                    }
                }

                // Show audio level indicator
                this.updateAudioLevel(maxStrength);

                return detectedTone;
            }

            updateAudioLevel(level) {
                const indicator = document.getElementById('audio-level');
                if (indicator) {
                    indicator.style.width = Math.min(100, level / 2) + '%';
                    indicator.style.background = level > 120 ? '#4CAF50' : '#ff9800';
                }
            }

            // Get detection statistics
            getDetectionStats() {
                const stats = { ...this.detectionStats };
                if (stats.total > 0) {
                    stats.enhancedPercent = ((stats.enhanced / stats.total) * 100).toFixed(1);
                    stats.originalPercent = ((stats.original / stats.total) * 100).toFixed(1);
                }
                return stats;
            }

            // Switch detection mode
            setDetectionMode(mode) {
                if (['original', 'enhanced', 'hybrid'].includes(mode)) {
                    this.detectionMode = mode;
                    console.log(`Detection mode changed to: ${mode}`);
                    return true;
                }
                return false;
            }

            // Switch windowing type
            setWindowType(type) {
                if (['hamming', 'hann', 'blackman'].includes(type)) {
                    this.windowType = type;
                    console.log(`Windowing type changed to: ${type}`);
                    return true;
                }
                return false;
            }

            // Reset detection statistics
            resetDetectionStats() {
                this.detectionStats = { enhanced: 0, original: 0, total: 0 };
                console.log('Detection statistics reset');
            }

            // Demo function to test different detection modes
            async demoDetectionModes() {
                console.log('🎵 FFT Windowing Detection Demo');
                console.log('================================');

                const modes = ['original', 'enhanced', 'hybrid'];
                const windows = ['hamming', 'hann', 'blackman'];

                for (const mode of modes) {
                    console.log(`\n--- Testing ${mode.toUpperCase()} mode ---`);
                    this.setDetectionMode(mode);
                    this.resetDetectionStats();

                    // Test each windowing type
                    for (const windowType of windows) {
                        this.setWindowType(windowType);
                        console.log(`Window: ${windowType}`);

                        // Simulate some detection cycles (in real usage this would happen naturally)
                        await new Promise(resolve => setTimeout(resolve, 100));

                        const stats = this.getDetectionStats();
                        console.log(`  Stats: ${stats.enhanced || 0} enhanced, ${stats.original || 0} original (${stats.total || 0} total)`);
                    }
                }

                console.log('\nDemo complete! Current settings:');
                console.log(`Mode: ${this.detectionMode}, Window: ${this.windowType}`);
            }

            // Generate test tone for validation
            generateTestTone(frequency, duration = 1000) {
                if (!this.audioContext) {
                    console.error('Audio context not initialized');
                    return;
                }

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration / 1000);

                console.log(`Generated test tone: ${frequency}Hz for ${duration}ms`);
            }

            async handleTone(tone) {
                // Handle speed test acknowledgments when sender is waiting
                if (this.role === 'sender' && this.waitingForSpeedAck) {
                    if (Math.abs(tone.freq - this.tones.ACK) < 100) {
                        console.log('Sender received ACK for speed test');
                        this.speedAckReceived = true;
                        return;
                    } else if (Math.abs(tone.freq - this.tones.ERROR) < 100) {
                        console.log('Sender received NACK for speed test');
                        this.speedNackReceived = true;
                        return;
                    }
                }

                // Rest of receiver handling
                if (this.role !== 'receiver') return;

                // Check for speed test response if we're waiting for one
                if (this.waitingForSpeedAck) {
                    if (tone.name === 'ACK' || Math.abs(tone.freq - this.tones.ACK) < 100) {
                        this.speedAckReceived = true;
                        console.log('Speed ACK received');
                        return;
                    } else if (tone.name === 'ERROR' || tone.name === 'NACK' || Math.abs(tone.freq - this.tones.ERROR) < 100) {
                        this.speedNackReceived = true;
                        console.log('Speed NACK received');
                        return;
                    }
                }

                // Detect speed test marker
                if (Math.abs(tone.freq - 2500) < 100) {
                    this.state = 'speed_test';
                    this.testBuffer = '';
                    this.testStartTime = Date.now();
                    console.log('Receiver: Speed test detected');
                    return;
                }

                // Handle speed test
                if (this.state === 'speed_test') {
                    if (tone.freq >= 2900 && tone.freq <= 4600) {
                        const hexVal = Math.round((tone.freq - 3000) / 100);
                        if (hexVal >= 0 && hexVal <= 15) {
                            this.testBuffer += hexVal.toString(16);

                            // Try to decode what we have so far
                            if (this.testBuffer.length >= 10 && this.testBuffer.length % 2 === 0) {
                                try {
                                    const decoded = this.hexToString(this.testBuffer);
                                    console.log('Receiver decoded:', decoded);

                                    if (decoded.startsWith('TEST_')) {
                                        // Success! Send ACK immediately
                                        console.log('Receiver: Speed test passed, sending ACK');

                                        // CRITICAL: Wait a moment for sender to start listening
                                        await this.delay(200);

                                        this.pauseListening();
                                        await this.playTone(this.tones.ACK, 200); // Longer ACK
                                        await this.delay(100);
                                        await this.playTone(this.tones.ACK, 200); // Send twice for reliability
                                        this.resumeListening();

                                        this.state = 'waiting_for_sender';
                                        this.updateStatus('✅ Speed test passed');
                                        this.testBuffer = '';
                                        return;
                                    }
                                } catch(e) {
                                    console.log('Receiver: Failed to decode speed test');
                                }
                            }

                            // If buffer gets too long without success, it failed
                            if (this.testBuffer.length > 20) {
                                console.log('Receiver: Speed test failed, sending ERROR');
                                this.pauseListening();
                                await this.playTone(this.tones.ERROR, 200);
                                this.resumeListening();

                                this.state = 'waiting_for_sender';
                                this.testBuffer = '';
                            }
                        }
                    }

                    // Timeout speed test
                    if (Date.now() - this.testStartTime > 2000) {
                        console.log('Receiver: Speed test timeout');
                        this.state = 'waiting_for_sender';
                        this.testBuffer = '';
                    }

                    return;
                }

                // Add noise floor filtering
                if (tone.strength < 100) return; // Ignore weak signals

                // Detect start pattern (be more lenient with frequency detection)
                if (this.state === 'waiting_for_sender') {
                    if (Math.abs(tone.freq - 3000) < 150) { // Within 150Hz of 3000
                        this.state = 'receiving_header';
                        this.headerBuffer = '';
                        this.updateStatus('📥 Receiving header...');
                        console.log('Start pattern detected');
                    }
                }

                // Receive length header
                else if (this.state === 'receiving_header') {
                    if (tone.freq >= 2900 && tone.freq <= 4600) {
                        const hexVal = Math.round((tone.freq - 3000) / 100);
                        if (hexVal >= 0 && hexVal <= 15) { // Valid hex digit
                            this.headerBuffer += hexVal.toString(16);
                            console.log('Header byte:', hexVal.toString(16), 'Total:', this.headerBuffer);

                            if (this.headerBuffer.length === 4) {
                                this.expectedLength = parseInt(this.headerBuffer, 16);
                                this.dataBuffer = '';
                                this.state = 'receiving_data';
                                this.updateStatus(`📥 Expecting ${this.expectedLength} bytes...`);
                                console.log('Expected data length:', this.expectedLength);
                            }
                        }
                    }
                }

                // Receive data
                else if (this.state === 'receiving_data') {
                    if (tone.freq >= 2900 && tone.freq <= 4600) {
                        const hexVal = Math.round((tone.freq - 3000) / 100);
                        if (hexVal >= 0 && hexVal <= 15) { // Valid hex digit
                            this.dataBuffer += hexVal.toString(16);

                            if (this.dataBuffer.length % 32 === 0) {
                                const percent = Math.round(this.dataBuffer.length * 100 / this.expectedLength);
                                this.updateStatus(`📥 Received ${percent}%`);
                            }

                            if (this.dataBuffer.length >= this.expectedLength) {
                                console.log('All data received, processing...');
                                this.processReceivedData();
                            }
                        }
                    }

                    // Detect end pattern (optional safety)
                    if (Math.abs(tone.freq - 4000) < 150 && this.dataBuffer.length > 0) {
                        console.log('End pattern detected, forcing process');
                        this.processReceivedData();
                    }
                }
            }

            pauseListening() {
                this.isListening = false;
                // Also clear any pending analysis frames
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
            }

            resumeListening() {
                this.isListening = true;
                // Restart the listening loop if needed
                if (this.listen && !this.animationFrame) {
                    this.listen();
                }
            }

            async transmitData() {
                const TONE_DURATION = 20;  // Was 80ms - 4x faster
                const INTER_BIT_DELAY = 5; // Was 30ms - 6x faster
                // This gives ~25ms per bit = 4x faster total transmission

                // Prepare minimal data
                const data = {
                    u: currentUsername.substring(0, 10),
                    a: {}
                };

                const answers = classData.users[currentUsername].answers;
                const recent = Object.keys(answers).slice(-3);
                recent.forEach(qId => {
                    const shortId = qId.substring(qId.lastIndexOf('-') + 1);
                    data.a[shortId] = answers[qId].value || answers[qId];
                });

                const json = JSON.stringify(data);
                const binary = this.stringToBinary(json);

                // Send data length first (16 bits)
                const lengthBits = binary.length.toString(2).padStart(16, '0');

                // Send length - no delays
                for (let bit of lengthBits) {
                    await this.playTone(
                        bit === '1' ? this.tones.DATA_1 : this.tones.DATA_0,
                        TONE_DURATION
                    );
                    // Removed delay between length bits
                }

                // Send data - no delays
                for (let i = 0; i < binary.length; i++) {
                    const bit = binary[i];
                    await this.playTone(
                        bit === '1' ? this.tones.DATA_1 : this.tones.DATA_0,
                        TONE_DURATION
                    );
                    // Removed delay between data bits

                    if (i % 8 === 0) {
                        this.updateStatus(`Sending: ${Math.round(i * 100 / binary.length)}%`);
                    }
                }

                // Quick DONE signal
                await this.playTone(this.tones.DONE, 50);

                // After sending DONE, switch to listening for response data
                this.state = 'waiting_peer_data';
                this.updateStatus('👂 Listening for peer data...');
                this.resumeListening();
            }

            async transmitDataReliable() {
                // Prepare minimal data packet with sequence number
                const data = {
                    u: currentUsername.substring(0, 10),
                    a: {},
                    seq: this.lastSequenceNumber || 0, // Add sequence number for retransmission tracking
                    t: Date.now() // Add timestamp for uniqueness
                };

                const answers = classData.users[currentUsername]?.answers || {};
                const recent = Object.keys(answers).slice(-5); // Last 5 answers

                recent.forEach(qId => {
                    const shortId = qId.substring(qId.lastIndexOf('-') + 1);
                    data.a[shortId] = answers[qId].value || answers[qId];
                });

                const json = JSON.stringify(data);
                const hexData = this.stringToHex(json);

                // Validate data before transmission
                if (!json || json.length === 0) {
                    throw new Error('No data to transmit');
                }

                if (hexData.length > 10000) { // Reasonable limit to prevent extremely long transmissions
                    throw new Error('Data too large for reliable transmission');
                }

                // Calculate CRC8 checksum for error detection
                const checksum = crc8(json);
                const checksumHex = checksum.toString(16).padStart(2, '0');
                console.log('Data checksum:', checksumHex, 'Data length:', json.length, 'Hex length:', hexData.length);

                this.lastSequenceNumber = (this.lastSequenceNumber || 0) + 1;

                // Retry mechanism for failed transmissions
                const maxRetries = 3;
                let retryCount = 0;
                let transmissionSuccess = false;

                while (!transmissionSuccess && retryCount < maxRetries) {
                    try {
                        await this.sendDataWithErrorRecovery(hexData, checksumHex, retryCount);
                        transmissionSuccess = true;
                        console.log(`✅ Transmission successful on attempt ${retryCount + 1}/${maxRetries}`);

                        // Log successful transmission details
                        console.log('Transmission summary:', {
                            sequenceNumber: data.seq,
                            dataLength: json.length,
                            hexLength: hexData.length,
                            checksum: checksumHex,
                            attempts: retryCount + 1
                        });

                    } catch (error) {
                        retryCount++;
                        console.warn(`❌ Transmission attempt ${retryCount} failed:`, error.message);
                        if (retryCount < maxRetries) {
                            this.updateStatus(`⚠️ Retry ${retryCount}/${maxRetries} in 2s...`);
                            await this.delay(2000); // Wait before retry
                        } else {
                            console.error('🚫 Transmission failed after all retries:', {
                                totalAttempts: maxRetries,
                                finalError: error.message,
                                sequenceNumber: data.seq
                            });
                            this.updateStatus('❌ Transmission failed after all retries');
                            throw new Error(`Transmission failed after ${maxRetries} attempts: ${error.message}`);
                        }
                    }
                }

                this.updateStatus('✅ Transmission complete!');

                setTimeout(() => this.complete(), 2000);
            }

            // Helper method for sending data with error recovery
            async sendDataWithErrorRecovery(hexData, checksumHex, retryAttempt) {
                try {
                    // Add retry indicator to status for retries
                    const retryPrefix = retryAttempt > 0 ? `🔄 Retry ${retryAttempt}: ` : '';

                    this.updateStatus(`${retryPrefix}📡 Sending header...`);

                    // Send start pattern (with retry indicator)
                    if (retryAttempt > 0) {
                        await this.playTone(4500, 150); // Different start pattern for retries
                        await this.delay(100);
                    }

                    await this.playTone(3000, 100);
                    await this.playTone(3500, 100);
                    await this.playTone(4000, 100);

                    // Send length (4 hex digits)
                    const lengthHex = hexData.length.toString(16).padStart(4, '0');
                    console.log(`${retryPrefix}Sending length:`, lengthHex);

                    for (let char of lengthHex) {
                        const freq = 3000 + (parseInt(char, 16) * 100);
                        await this.playTone(freq, 50);
                        await this.delay(25);
                    }

                    await this.delay(100); // Pause between header and data

                    // Send data with error detection
                    for (let i = 0; i < hexData.length; i++) {
                        const hexChar = parseInt(hexData[i], 16);
                        const freq = 3000 + (hexChar * 100);
                        await this.playTone(freq, 50);
                        await this.delay(25);

                        if (i % 16 === 0) {
                            this.updateStatus(`${retryPrefix}📤 Sending: ${Math.round(i * 100 / hexData.length)}%`);
                        }

                        // Add periodic sync pauses (more frequent on retries)
                        const syncInterval = retryAttempt > 0 ? 16 : 32;
                        if (i % syncInterval === syncInterval - 1) {
                            await this.delay(100); // Sync pause
                        }
                    }

                    // Send checksum after data
                    this.updateStatus(`${retryPrefix}🔒 Sending checksum...`);
                    await this.delay(100); // Pause before checksum

                    for (let char of checksumHex) {
                        const freq = 3000 + (parseInt(char, 16) * 100);
                        await this.playTone(freq, 70); // Slightly longer for checksum
                        await this.delay(30);
                    }

                    // Send end pattern
                    await this.playTone(4000, 100);
                    await this.playTone(3500, 100);
                    await this.playTone(3000, 100);

                } catch (error) {
                    console.error(`Transmission error on attempt ${retryAttempt + 1}:`, error.message);
                    // Log transmission details for debugging
                    console.error('Transmission details:', {
                        attempt: retryAttempt + 1,
                        dataLength: hexData.length,
                        checksum: checksumHex,
                        error: error.message
                    });
                    throw error; // Re-throw to trigger retry mechanism
                }
            }

            async transmitDataFast() {
                const TONE_DURATION = this.config.TONE_DURATION;
                const INTER_TONE_DELAY = this.config.INTER_SYMBOL_DELAY;

                // Prepare minimal data with compression
                const data = {
                    u: currentUsername.substring(0, 10),
                    a: {}
                };

                const answers = classData.users[currentUsername].answers;
                const recent = Object.keys(answers).slice(-3);
                recent.forEach(qId => {
                    const shortId = qId.substring(qId.lastIndexOf('-') + 1);
                    data.a[shortId] = answers[qId].value || answers[qId];
                });

                // Compress JSON by removing whitespace for faster transmission (config.COMPRESSION enabled)
                const json = JSON.stringify(data);
                const compressed = json.replace(/\s+/g, '');
                const hexData = this.stringToHex(compressed);

                // Send data length first (16 bits as hex) - no delays
                const lengthHex = hexData.length.toString(16).padStart(4, '0'); // 4 hex chars = 16 bits

                // Send length with parallel channels for maximum speed
                if (this.config.PARALLEL_CHANNELS === 2) {
                    await this.transmitParallel(lengthHex);
                } else {
                    // Fallback to single channel
                    for (let i = 0; i < lengthHex.length; i++) {
                        const hexChar = parseInt(lengthHex[i], 16);
                        await this.playTone(this.dataFrequencies[hexChar], TONE_DURATION);
                    }
                }

                // Send data with parallel channels for maximum speed
                if (this.config.PARALLEL_CHANNELS === 2) {
                    await this.transmitParallel(hexData);
                } else {
                    // Fallback to single channel
                    for (let i = 0; i < hexData.length; i++) {
                        const hexChar = parseInt(hexData[i], 16);
                        await this.playTone(this.dataFrequencies[hexChar], TONE_DURATION);

                        if (i % 16 === 0) {
                            this.updateStatus(`Sending: ${Math.round(i * 100 / hexData.length)}%`);
                        }
                    }
                }

                // Quick DONE signal
                await this.playTone(this.tones.DONE, 50);

                // After sending DONE, switch to listening for response data
                this.state = 'waiting_peer_data';
                this.updateStatus('👂 Listening for peer data...');
                this.resumeListening();
            }

            // Parallel channel transmission for maximum speed
            async transmitParallel(hexData) {
                const TONE_DURATION = this.config.TONE_DURATION;
                const INTER_TONE_DELAY = this.config.INTER_SYMBOL_DELAY;

                // Process data in pairs for parallel transmission
                for (let i = 0; i < hexData.length; i += 2) {
                    const hexChar1 = parseInt(hexData[i], 16);
                    const hexChar2 = i + 1 < hexData.length ? parseInt(hexData[i + 1], 16) : 0;

                    // Transmit both channels simultaneously
                    const tone1 = this.playTone(this.channel1Freqs[hexChar1], TONE_DURATION);
                    const tone2 = this.playTone(this.channel2Freqs[hexChar2], TONE_DURATION);

                    // Wait for both tones to complete
                    await Promise.all([tone1, tone2]);

                    // Minimal delay between symbol pairs
                    if (INTER_TONE_DELAY > 0) {
                        await this.delay(INTER_TONE_DELAY);
                    }

                    if (i % 32 === 0) {
                        this.updateStatus(`Sending: ${Math.round(i * 100 / hexData.length)}%`);
                    }
                }
            }

            // Progressive Fallback Strategy - Start optimistic, fall back gracefully
            async smartTransmit(data) {
                // Try fast parallel channels first
                if (await this.tryParallelTransmit(data)) return;

                // Fall back to single channel hex
                if (await this.trySingleChannelHex(data)) return;

                // Fall back to slow binary
                if (await this.tryBinaryTransmit(data)) return;

                // Ultimate fallback: show QR code
                this.showFallbackQR(data);
            }

            // Try parallel channel transmission (fastest method)
            async tryParallelTransmit(data) {
                try {
                    this.updateStatus('🚀 Trying parallel channel transmission...');
                    await this.transmitParallel(data);
                    this.updateStatus('✅ Parallel transmission successful');
                    return true;
                } catch (error) {
                    this.updateStatus('❌ Parallel transmission failed, trying fallback...');
                    return false;
                }
            }

            // Try single channel hex transmission
            async trySingleChannelHex(data) {
                // Temporarily disable parallel channels
                const originalChannels = this.config.PARALLEL_CHANNELS;
                try {
                    this.updateStatus('📡 Trying single channel hex transmission...');
                    this.config.PARALLEL_CHANNELS = 1;

                    await this.transmitWithAcks(data);

                    this.updateStatus('✅ Single channel hex transmission successful');
                    return true;
                } catch (error) {
                    this.updateStatus('❌ Single channel hex failed, trying binary...');
                    return false;
                } finally {
                    // Always restore original setting
                    this.config.PARALLEL_CHANNELS = originalChannels;
                }
            }

            // Try slow binary transmission (most compatible)
            async tryBinaryTransmit(data) {
                try {
                    this.updateStatus('🐌 Trying binary transmission...');
                    await this.transmitData(data);
                    this.updateStatus('✅ Binary transmission successful');
                    return true;
                } catch (error) {
                    this.updateStatus('❌ Binary transmission failed, showing QR code...');
                    return false;
                }
            }

            // Ultimate fallback: display QR code
            showFallbackQR(data) {
                this.updateStatus('📱 Displaying QR code fallback...');
                // Use existing QR functionality
                if (typeof showMyQR === 'function') {
                    // Store data for QR display
                    this.fallbackData = data;
                    showMyQR();
                } else {
                    alert('QR code fallback not available. Transmission failed.');
                }
            }

            // Bidirectional Acknowledgment Protocol
            // Send data in small blocks with ACKs for reliable transmission
            async transmitWithAcks(data) {
                const BLOCK_SIZE = 16; // hex chars per block

                this.updateStatus('📦 Starting reliable transmission...');

                for (let i = 0; i < data.length; i += BLOCK_SIZE) {
                    const block = data.slice(i, i + BLOCK_SIZE);
                    const blockIndex = Math.floor(i / BLOCK_SIZE);

                    let success = false;

                    // Try up to 3 times
                    for (let attempt = 0; attempt < 3; attempt++) {
                        this.updateStatus(`📤 Sending block ${blockIndex + 1} (attempt ${attempt + 1}/3)`);

                        // Send block with sequence number
                        await this.sendBlock(block, blockIndex);

                        // Wait for ACK with timeout
                        const ack = await this.waitForBlockAck(blockIndex, 500);
                        if (ack) {
                            success = true;
                            this.updateStatus(`✅ Block ${blockIndex + 1} acknowledged`);
                            break;
                        }

                        // Slow down on retry
                        this.config.TONE_DURATION *= 1.2;
                        this.updateStatus(`⏳ Block ${blockIndex + 1} timeout, retrying...`);
                        await this.delay(100); // Brief pause before retry
                    }

                    if (!success) {
                        throw new Error(`Failed to transmit block ${blockIndex + 1} after 3 attempts`);
                    }

                    // Reset tone duration after successful block
                    this.config.TONE_DURATION = Math.max(10, this.config.TONE_DURATION * 0.95);
                }

                // Send completion signal
                await this.playTone(this.tones.DONE, 100);
                this.updateStatus('🎉 Transmission completed successfully');
            }

            // Send individual block with sequence number
            async sendBlock(block, sequenceNumber) {
                // Send sequence number first (2 hex chars = 8 bits, supports up to 256 blocks)
                const seqHex = sequenceNumber.toString(16).padStart(2, '0');

                // Use parallel channels if enabled
                if (this.config.PARALLEL_CHANNELS === 2) {
                    await this.transmitParallel(seqHex);
                    await this.transmitParallel(block);
                } else {
                    // Send sequence
                    for (let i = 0; i < seqHex.length; i++) {
                        const hexChar = parseInt(seqHex[i], 16);
                        await this.playTone(this.dataFrequencies[hexChar], this.config.TONE_DURATION);
                        await this.delay(this.config.INTER_SYMBOL_DELAY);
                    }

                    // Send block data
                    for (let i = 0; i < block.length; i++) {
                        const hexChar = parseInt(block[i], 16);
                        await this.playTone(this.dataFrequencies[hexChar], this.config.TONE_DURATION);
                        await this.delay(this.config.INTER_SYMBOL_DELAY);
                    }
                }
            }

            // Wait for block acknowledgment
            async waitForBlockAck(expectedSequence, timeout = 500) {
                return new Promise((resolve) => {
                    const timeoutId = setTimeout(() => {
                        resolve(false); // Timeout - no ACK received
                    }, timeout);

                    // Store expected sequence for this ACK wait
                    this.expectedAckSequence = expectedSequence;

                    // Set up one-time handler for block ACK
                    const originalHandleTone = this.handleTone;
                    this.handleTone = (tone) => {
                        // Check if this is an ACK tone
                        if (tone.name === 'ACK') {
                            clearTimeout(timeoutId);
                            this.handleTone = originalHandleTone; // Restore original handler
                            delete this.expectedAckSequence; // Clean up
                            resolve(true); // ACK received
                        } else {
                            // Pass other tones to original handler
                            originalHandleTone.call(this, tone);
                        }
                    };
                });
            }

            // Send acknowledgment for received block
            async sendBlockAck(sequenceNumber) {
                // Send ACK tone to confirm block receipt
                await this.playTone(this.tones.ACK, 100);
                this.updateStatus(`📨 Sent ACK for block ${sequenceNumber + 1}`);
            }

            // Receive data with bidirectional acknowledgments
            async receiveWithAcks() {
                this.updateStatus('👂 Listening for reliable transmission...');
                this.state = 'receiving_blocks';
                this.receivedBlocks = new Map(); // Store received blocks by sequence
                this.nextExpectedSequence = 0;

                // Set up handler for incoming blocks
                const originalHandleTone = this.handleTone;
                this.handleTone = async (tone) => {
                    if (tone.name === 'DONE') {
                        // Transmission complete
                        this.handleTone = originalHandleTone;
                        this.state = 'idle';
                        this.processReceivedData();
                        return;
                    }

                    // Handle data tones (blocks come as sequence + data)
                    if (tone.name.startsWith('DATA_') || tone.hexValue !== undefined) {
                        await this.handleIncomingBlock(tone);
                    } else {
                        // Pass other tones to original handler
                        originalHandleTone.call(this, tone);
                    }
                };
            }

            // Handle incoming block data
            async handleIncomingBlock(tone) {
                let hexValue;

                if (tone.hexValue !== undefined) {
                    hexValue = tone.hexValue.toString(16);
                } else if (tone.name === 'DATA_0') {
                    hexValue = '0';
                } else if (tone.name === 'DATA_1') {
                    hexValue = '1';
                } else {
                    return; // Not a data tone
                }

                // Accumulate block data
                if (!this.currentBlock) {
                    this.currentBlock = {
                        sequence: null,
                        data: '',
                        expectedLength: 16 // Default block size
                    };
                }

                // First 2 characters are sequence number
                if (this.currentBlock.data.length < 2) {
                    this.currentBlock.sequenceHex = (this.currentBlock.sequenceHex || '') + hexValue;
                    if (this.currentBlock.sequenceHex.length === 2) {
                        this.currentBlock.sequence = parseInt(this.currentBlock.sequenceHex, 16);
                    }
                } else {
                    // Rest is block data
                    this.currentBlock.data += hexValue;

                    // Check if block is complete
                    if (this.currentBlock.data.length >= this.currentBlock.expectedLength + 2) {
                        const sequence = this.currentBlock.sequence;
                        const blockData = this.currentBlock.data.substring(2); // Remove sequence prefix

                        // Store the block
                        this.receivedBlocks.set(sequence, blockData);

                        // Send ACK for this block
                        await this.sendBlockAck(sequence);

                        // Reset for next block
                        this.currentBlock = null;

                        this.updateStatus(`📦 Received block ${sequence + 1}`);
                    }
                }
            }

            // Process complete received data
            processReceivedData() {
    try {
        console.log('Processing received data:', this.dataBuffer);

        // Convert hex back to string
        const decoded = this.hexToString(this.dataBuffer);
        console.log('Decoded string:', decoded);

        const data = JSON.parse(decoded);
        console.log('Parsed data:', data);

        // Import the data
        if (data && data.u && data.a) {
            const imported = {
                users: {
                    [data.u]: {
                        answers: data.a,
                        timestamps: {},
                        reasons: {},
                        attempts: {}
                    }
                }
            };

            mergeClassData(imported);
            this.updateStatus(`✅ Received data from ${data.u}!`);

            setTimeout(() => this.complete(), 2000);
        } else {
            throw new Error('Invalid data structure');
        }

    } catch(err) {
        console.error('Data processing error:', err);
        console.error('Raw buffer:', this.dataBuffer);
        console.error('Buffer length:', this.dataBuffer.length);
        console.error('Expected length:', this.expectedLength);

        this.updateStatus(`❌ Error: ${err.message}`);

        // Try to salvage partial data
        if (this.dataBuffer.length > 0) {
            try {
                // Try decoding what we have
                const partial = this.hexToString(this.dataBuffer.substring(0, Math.floor(this.dataBuffer.length / 2) * 2));
                console.log('Partial decode attempt:', partial);
            } catch(e) {
                console.error('Could not decode partial data');
            }
        }
    }
}

            // Start a reliable transfer using the bidirectional ACK protocol
            async startReliableTransfer() {
                try {
                    this.updateStatus('🔄 Preparing reliable transfer...');

                    // Prepare sample data (or use real data from the application)
                    const sampleData = this.prepareSampleData();

                    // Convert to hex for transmission
                    const hexData = this.stringToHex(sampleData);

                    this.updateStatus(`📊 Prepared ${hexData.length} hex characters for transmission`);

                    // Start the handshake process
                    await this.startHandshake();

                    // Wait a moment for handshake to complete
                    await this.delay(1000);

                    // Use the bidirectional ACK protocol
                    await this.transmitWithAcks(hexData);

                } catch (error) {
                    this.updateStatus(`❌ Transfer failed: ${error.message}`);
                    console.error('Reliable transfer error:', error);
                }
            }

            // Prepare sample data for demonstration
            prepareSampleData() {
                // Use current user data or create sample data
                if (currentUsername && classData.users[currentUsername]) {
                    const userData = classData.users[currentUsername];
                    const answers = userData.answers || {};
                    return JSON.stringify({
                        user: currentUsername.substring(0, 10),
                        timestamp: new Date().toISOString(),
                        answers: Object.keys(answers).slice(-5) // Last 5 answers
                    });
                } else {
                    // Fallback sample data
                    return JSON.stringify({
                        type: 'sample_data',
                        timestamp: new Date().toISOString(),
                        message: 'Bidirectional ACK Protocol Demo',
                        data: '0123456789abcdef'.repeat(10) // 160 characters
                    });
                }
            }

            // Handle parallel channel data reception
            handleParallelData(hexValue) {
                // Store channel data separately for parallel processing
                if (!this.channelData) {
                    this.channelData = { ch1: '', ch2: '' };
                }

                // Determine which channel this hex value came from based on frequency
                // Channel 1: 3000-4500 Hz, Channel 2: 5000-6500 Hz
                const toneFreq = this.dataFrequencies[parseInt(hexValue, 16)];
                const channel = toneFreq >= 5000 ? 2 : 1;

                if (channel === 1) {
                    this.channelData.ch1 += hexValue;
                } else {
                    this.channelData.ch2 += hexValue;
                }

                // Process when we have data from both channels
                const combinedLength = this.channelData.ch1.length + this.channelData.ch2.length;

                // First 4 hex chars are length (16 bits) - expect 2 from each channel
                if (this.expectedLength === 0) {
                    if (this.channelData.ch1.length >= 2 && this.channelData.ch2.length >= 2) {
                        const lengthHex = this.channelData.ch1.substring(0, 2) + this.channelData.ch2.substring(0, 2);
                        this.expectedLength = parseInt(lengthHex, 16);
                        this.channelData.ch1 = this.channelData.ch1.substring(2);
                        this.channelData.ch2 = this.channelData.ch2.substring(2);
                        this.updateStatus(`Expecting ${this.expectedLength} hex chars...`);
                    }
                } else {
                    // Actual data - interleave from both channels
                    if (this.channelData.ch1.length > 0 && this.channelData.ch2.length > 0) {
                        // Take one char from each channel alternately
                        this.dataBuffer += this.channelData.ch1[0] + this.channelData.ch2[0];
                        this.channelData.ch1 = this.channelData.ch1.substring(1);
                        this.channelData.ch2 = this.channelData.ch2.substring(1);

                        if (this.dataBuffer.length % 32 === 0) {
                            this.updateStatus(`Received ${this.dataBuffer.length}/${this.expectedLength} hex chars`);
                        }

                        if (this.dataBuffer.length >= this.expectedLength) {
                            this.processReceivedDataFast();
                        }
                    }
                }
            }

            // Handle single channel data reception (fallback)
            handleSingleChannelData(hexValue) {
                // First 4 hex chars are length (16 bits)
                if (this.expectedLength === 0) {
                    this.dataBuffer += hexValue;

                    if (this.dataBuffer.length === 4) {
                        this.expectedLength = parseInt(this.dataBuffer, 16);
                        this.dataBuffer = '';
                        this.updateStatus(`Expecting ${this.expectedLength} hex chars...`);
                    }
                } else {
                    // Actual data
                    this.dataBuffer += hexValue;

                    if (this.dataBuffer.length % 16 === 0) {
                        this.updateStatus(`Received ${this.dataBuffer.length}/${this.expectedLength} hex chars`);
                    }

                    if (this.dataBuffer.length >= this.expectedLength) {
                        this.processReceivedDataFast();
                    }
                }
            }

            processReceivedData() {
                try {
                    // First 16 bits were length
                    const lengthBits = this.dataBuffer.substring(0, 16);
                    const dataLength = parseInt(lengthBits, 2);
                    const dataBits = this.dataBuffer.substring(16, 16 + dataLength);

                    const decoded = this.binaryToString(dataBits);
                    const data = JSON.parse(decoded);

                    // Send ACK - faster
                    this.pauseListening();
                    setTimeout(async () => {
                        await this.playTone(this.tones.ACK, 100); // Faster ACK
                        this.updateStatus(`✅ Received data from ${data.u}!`);

                        // Import the data
                        const imported = {
                            users: {
                                [data.u]: {
                                    answers: data.a,
                                    timestamps: {},
                                    reasons: {},
                                    attempts: {}
                                }
                            }
                        };

                        mergeClassData(imported);
                        setTimeout(() => this.complete(), 1500);

                    }, 500);

                } catch(err) {
                    console.error('Data error:', err);
                    this.updateStatus('❌ Error processing data');
                    this.playTone(this.tones.ERROR, 500);
                }
            }

            processReceivedDataFast() {
                try {
                    // dataBuffer contains hex characters
                    const decoded = this.hexToString(this.dataBuffer);
                    const data = JSON.parse(decoded);

                    // Send ACK - faster
                    this.pauseListening();
                    setTimeout(async () => {
                        await this.playTone(this.tones.ACK, 100); // Faster ACK
                        this.updateStatus(`✅ Received data from ${data.u}!`);

                        // Import the data
                        const imported = {
                            users: {
                                [data.u]: {
                                    answers: data.a,
                                    timestamps: {},
                                    reasons: {},
                                    attempts: {}
                                }
                            }
                        };

                        mergeClassData(imported);
                        setTimeout(() => this.complete(), 1500);

                    }, 500);

                } catch(err) {
                    console.error('Data error:', err);
                    this.updateStatus('❌ Error processing data');
                    this.playTone(this.tones.ERROR, 500);
                }
            }

            complete() {
                this.stopListening();
                document.getElementById('audio-protocol')?.remove();
                loadProgress();
            }

            stopListening() {
                this.isListening = false;
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                }
                clearTimeout(this.timeout);
            }

            // Better UI with audio level indicator
            showHandshakeUI() {
                const modal = document.createElement('div');
                modal.id = 'audio-protocol';
                modal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 3000; padding: 20px;';

                modal.innerHTML = `
                    <div style="max-width: 400px; margin: 50px auto; text-align: center;">
                        <h2>🔊 Audio Transfer - Sending</h2>

                        <div style="font-size: 60px; margin: 20px;">📡</div>

                        <div id="protocol-status" style="padding: 20px; background: #f0f0f0; border-radius: 8px; margin: 20px 0;">
                            Initializing...
                        </div>

                        <!-- Audio level indicator -->
                        <div style="background: #e0e0e0; height: 10px; border-radius: 5px; margin: 20px 0;">
                            <div id="audio-level" style="height: 100%; width: 0%; background: #ff9800; border-radius: 5px; transition: width 0.1s;"></div>
                        </div>
                        <small>Audio Level (should pulse when receiving)</small>

                        <button onclick="audioProtocol.cancel()" class="submit-button" style="background: #f44336; margin-top: 20px;">
                            Cancel Transfer
                        </button>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            showResponderUI() {
                const modal = document.createElement('div');
                modal.id = 'audio-protocol';
                modal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 3000; padding: 20px;';

                modal.innerHTML = `
                    <div style="max-width: 400px; margin: 50px auto; text-align: center;">
                        <h2>🎤 Audio Transfer - Receiving</h2>

                        <div style="font-size: 60px; margin: 20px;">👂</div>

                        <div id="protocol-status" style="padding: 20px; background: #f0f0f0; border-radius: 8px; margin: 20px 0;">
                            Listening for connection...
                        </div>

                        <!-- Audio level indicator -->
                        <div style="background: #e0e0e0; height: 10px; border-radius: 5px; margin: 20px 0;">
                            <div id="audio-level" style="height: 100%; width: 0%; background: #ff9800; border-radius: 5px; transition: width 0.1s;"></div>
                        </div>
                        <small>Audio Level (should pulse when hearing tones)</small>

                        <button onclick="audioProtocol.cancel()" class="submit-button" style="background: #f44336; margin-top: 20px;">
                            Cancel Transfer
                        </button>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            showSenderUI() {
                const modal = document.createElement('div');
                modal.id = 'audio-protocol';
                modal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 3000; padding: 20px;';

                modal.innerHTML = `
                    <div style="max-width: 400px; margin: 50px auto; text-align: center;">
                        <h2>📤 Sending Data</h2>
                        <div style="font-size: 60px; margin: 20px;">🔊</div>

                        <div id="protocol-status" style="padding: 20px; background: #e8f5e9; border-radius: 8px; margin: 20px 0;">
                            Preparing to send...
                        </div>

                        <div style="text-align: left; padding: 10px; background: #f0f0f0; border-radius: 5px;">
                            <strong>Instructions:</strong><br>
                            1. Make sure receiver clicked "Receive Data"<br>
                            2. Keep volume at 75% or higher<br>
                            3. Hold devices 1-2 feet apart<br>
                            4. Wait for completion message
                        </div>

                        <button onclick="audioProtocol.cancel()" class="submit-button" style="background: #f44336; margin-top: 20px;">
                            Cancel
                        </button>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            showReceiverUI() {
                const modal = document.createElement('div');
                modal.id = 'audio-protocol';
                modal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 3000; padding: 20px;';

                modal.innerHTML = `
                    <div style="max-width: 400px; margin: 50px auto; text-align: center;">
                        <h2>📥 Receiving Data</h2>
                        <div style="font-size: 60px; margin: 20px;">👂</div>

                        <div id="protocol-status" style="padding: 20px; background: #e3f2fd; border-radius: 8px; margin: 20px 0;">
                            Listening for sender...
                        </div>

                        <div style="background: #e0e0e0; height: 10px; border-radius: 5px; margin: 20px 0;">
                            <div id="audio-level" style="height: 100%; width: 0%; background: #2196F3; border-radius: 5px; transition: width 0.1s;"></div>
                        </div>
                        <small>Audio Level Indicator</small>

                        <button onclick="audioProtocol.cancel()" class="submit-button" style="background: #f44336; margin-top: 20px;">
                            Cancel
                        </button>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            updateStatus(message) {
                const status = document.getElementById('protocol-status');
                if (status) {
                    const listeningIndicator = this.isListening ? '🎧' : '🔇';
                    status.textContent = `${listeningIndicator} ${message}`;
                }
            }

            updateDataProgress() {
                const progress = document.getElementById('data-progress');
                const count = document.getElementById('bit-count');
                if (progress) progress.style.display = 'block';
                if (count) count.textContent = this.dataBuffer.length;
            }

            cancel() {
                this.stopListening();
                document.getElementById('audio-protocol')?.remove();
            }

            // Helper methods
            async playTone(frequency, duration) {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.6, this.audioContext.currentTime);

                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration/1000);

                return new Promise(resolve => setTimeout(resolve, duration));
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            stringToBinary(str) {
                return str.split('').map(char =>
                    char.charCodeAt(0).toString(2).padStart(8, '0')
                ).join('');
            }

            binaryToString(binary) {
                let str = '';
                for (let i = 0; i < binary.length; i += 8) {
                    str += String.fromCharCode(parseInt(binary.substr(i, 8), 2));
                }
                return str;
            }

            stringToHex(str) {
                let hex = '';
                for (let i = 0; i < str.length; i++) {
                    hex += str.charCodeAt(i).toString(16).padStart(2, '0');
                }
                return hex;
            }

            hexToString(hex) {
                // Debug: Log input
                console.log('hexToString input:', hex);

                // Clean the hex string first
                const originalHex = hex;
                hex = hex.replace(/[^0-9a-fA-F]/g, '');
                console.log('hexToString cleaned hex:', hex, '(original length:', originalHex.length, ', cleaned length:', hex.length + ')');

                // Ensure even length
                if (hex.length % 2 !== 0) {
                    console.warn('hexToString: Odd length hex string, truncating:', hex.length);
                    hex = hex.substring(0, hex.length - 1);
                    console.log('hexToString: After truncation:', hex);
                }

                let str = '';
                console.log('hexToString: Processing', Math.floor(hex.length / 2), 'bytes');

                for (let i = 0; i < hex.length; i += 2) {
                    const byte = hex.substr(i, 2);
                    const charCode = parseInt(byte, 16);

                    // Debug: Log each byte conversion
                    console.log('hexToString: Byte', byte, '-> charCode', charCode);

                    // Validate character code
                    if (charCode > 0 && charCode < 128) { // ASCII range
                        str += String.fromCharCode(charCode);
                        console.log('hexToString: Added character:', String.fromCharCode(charCode));
                    } else {
                        console.warn('hexToString: Invalid char code:', charCode, 'from byte:', byte, '- skipping');
                    }
                }

                console.log('hexToString: Final result:', str, '(length:', str.length + ')');
                return str;
            }

            // Add this method to AudioProtocol class
            async calibrateChannel() {
                // First, test frequency bands to find the cleanest one
                try {
                    const bestBand = await this.findBestBand();
                    this.updateStatus(`🎯 Using ${bestBand.name} frequency band for transmission`);

                    // Could potentially adjust data frequencies based on best band
                    // For now, we just log the information
                    console.log(`Best frequency band: ${bestBand.name} (${bestBand.start}-${bestBand.end}Hz, SNR: ${bestBand.snr.toFixed(2)})`);
                } catch (error) {
                    this.updateStatus(`⚠️ Frequency band testing failed: ${error.message}, proceeding with defaults...`);
                }

                const testRates = [
                    { duration: 50, delay: 20, name: 'slow' },     // ~14 symbols/sec
                    { duration: 20, delay: 10, name: 'medium' },   // ~33 symbols/sec
                    { duration: 10, delay: 5, name: 'fast' },      // ~66 symbols/sec
                    { duration: 5, delay: 2, name: 'ultrafast' }   // ~142 symbols/sec
                ];

                // Send test pattern at each rate
                for (let rate of testRates) {
                    await this.sendTestPattern(rate);
                    await this.waitForAck(rate.name);
                }
            }

            async sendTestPattern(rate) {
                // Send a test pattern using the specified rate parameters
                const testData = 'CALIBRATION_TEST_' + rate.name.toUpperCase();

                // Temporarily override config for this test
                const originalConfig = { ...this.config };
                this.config.TONE_DURATION = rate.duration;
                this.config.INTER_SYMBOL_DELAY = rate.delay;

                this.updateStatus(`🔧 Calibrating: Testing ${rate.name} rate...`);

                // Send test pattern
                await this.transmitText(testData);

                // Restore original config
                this.config = originalConfig;
            }

            async waitForAck(expectedRate) {
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error(`Timeout waiting for ${expectedRate} ACK`));
                    }, 5000); // 5 second timeout

                    // Set up one-time handler for ACK
                    const originalHandleTone = this.handleTone;
                    this.handleTone = (tone) => {
                        if (tone.freq === this.tones.ACK) {
                            clearTimeout(timeout);
                            this.handleTone = originalHandleTone; // Restore original handler
                            this.updateStatus(`✅ ${expectedRate} rate calibrated successfully`);
                            resolve();
                        } else {
                            // Pass other tones to original handler
                            originalHandleTone.call(this, tone);
                        }
                    };
                });
            }

            async sendTestPatternOnly(pattern, speed) {
                const profile = this.speedProfiles[speed];

                // Send speed test header
                await this.playTone(2500, 100); // Speed test marker
                await this.delay(50);

                // Send the pattern
                const hexPattern = this.stringToHex(pattern);

                for (let i = 0; i < hexPattern.length; i++) {
                    const hexChar = parseInt(hexPattern[i], 16);
                    const freq = 3000 + (hexChar * 100);
                    await this.playTone(freq, profile.toneDuration);
                    await this.delay(profile.interToneDelay);
                }

                console.log(`Sent test pattern: ${pattern}`);
            }

            async sendTestPattern(pattern, speed) {
                await this.sendTestPatternOnly(pattern, speed);
                return await this.waitForSpeedResponse(speed, 2000); // 2 second timeout
            }

            async waitForSpeedResponse(speed, timeout) {
                return new Promise((resolve) => {
                    let responded = false;
                    const startTime = Date.now();

                    // Set up a flag that handleTone can set
                    this.waitingForSpeedAck = true;
                    this.speedAckReceived = false;
                    this.speedNackReceived = false;

                    console.log(`Waiting ${timeout}ms for speed ${speed} response...`);

                    // Check periodically for response
                    const checkInterval = setInterval(() => {
                        if (this.speedAckReceived) {
                            console.log('ACK received!');
                            clearInterval(checkInterval);
                            this.waitingForSpeedAck = false;
                            responded = true;
                            resolve(true);
                        } else if (this.speedNackReceived) {
                            console.log('NACK received!');
                            clearInterval(checkInterval);
                            this.waitingForSpeedAck = false;
                            responded = true;
                            resolve(false);
                        } else if (Date.now() - startTime > timeout) {
                            console.log('Timeout waiting for response');
                            clearInterval(checkInterval);
                            this.waitingForSpeedAck = false;
                            if (!responded) {
                                resolve(false);
                            }
                        }
                    }, 100); // Check every 100ms
                });
            }

            // Frequency Band Testing Methods
            async measureBackgroundNoise(band) {
                return new Promise((resolve) => {
                    if (!this.audioContext) this.init();

                    // Create analyzer node
                    const analyser = this.audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    analyser.smoothingTimeConstant = 0.8;

                    // Get microphone input
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(stream => {
                            const source = this.audioContext.createMediaStreamSource(stream);
                            source.connect(analyser);

                            // Collect samples over 1 second
                            const samples = [];
                            const sampleInterval = setInterval(() => {
                                const bufferLength = analyser.frequencyBinCount;
                                const dataArray = new Uint8Array(bufferLength);
                                analyser.getByteFrequencyData(dataArray);

                                // Calculate average power in the band
                                const nyquist = this.audioContext.sampleRate / 2;
                                const startBin = Math.floor((band.start / nyquist) * bufferLength);
                                const endBin = Math.floor((band.end / nyquist) * bufferLength);

                                let sum = 0;
                                let count = 0;
                                for (let i = startBin; i <= endBin && i < bufferLength; i++) {
                                    sum += dataArray[i];
                                    count++;
                                }

                                if (count > 0) {
                                    samples.push(sum / count);
                                }
                            }, 100); // Sample every 100ms

                            // Stop after 1 second
                            setTimeout(() => {
                                clearInterval(sampleInterval);
                                stream.getTracks().forEach(track => track.stop());

                                // Return average noise level
                                const avgNoise = samples.length > 0 ?
                                    samples.reduce((a, b) => a + b, 0) / samples.length : 0;
                                resolve(avgNoise);
                            }, 1000);
                        })
                        .catch(error => {
                            console.warn('Could not access microphone for noise measurement:', error);
                            resolve(0); // Return 0 if we can't measure
                        });
                });
            }

            async testSignalStrength(band) {
                return new Promise(async (resolve) => {
                    if (!this.audioContext) this.init();

                    // Test frequency in the middle of the band
                    const testFreq = (band.start + band.end) / 2;

                    // Create analyzer for measuring response
                    const analyser = this.audioContext.createAnalyser();
                    analyser.fftSize = 2048;

                    // Get microphone input
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        const source = this.audioContext.createMediaStreamSource(stream);
                        source.connect(analyser);

                        // Play test tone
                        await this.playTone(testFreq, 500); // 500ms tone

                        // Wait a bit for the tone to propagate
                        await this.delay(100);

                        // Measure response
                        const bufferLength = analyser.frequencyBinCount;
                        const dataArray = new Uint8Array(bufferLength);
                        analyser.getByteFrequencyData(dataArray);

                        // Find peak in the band
                        const nyquist = this.audioContext.sampleRate / 2;
                        const startBin = Math.floor((band.start / nyquist) * bufferLength);
                        const endBin = Math.floor((band.end / nyquist) * bufferLength);

                        let maxSignal = 0;
                        for (let i = startBin; i <= endBin && i < bufferLength; i++) {
                            maxSignal = Math.max(maxSignal, dataArray[i]);
                        }

                        stream.getTracks().forEach(track => track.stop());
                        resolve(maxSignal);

                    } catch (error) {
                        console.warn('Could not test signal strength:', error);
                        resolve(0);
                    }
                });
            }

            async findBestBand() {
                this.updateStatus('🔍 Testing frequency bands for optimal performance...');

                for (let band of this.frequencyBands) {
                    this.updateStatus(`📡 Testing ${band.name} band (${band.start}-${band.end}Hz)...`);

                    const noise = await this.measureBackgroundNoise(band);
                    const signal = await this.testSignalStrength(band);

                    band.snr = signal / (noise + 1); // Signal-to-noise ratio (add 1 to avoid division by zero)
                    band.noise = noise;
                    band.signal = signal;
                }

                // Sort by SNR (best first)
                this.frequencyBands.sort((a, b) => b.snr - a.snr);

                const bestBand = this.frequencyBands[0];
                this.updateStatus(`✅ Best band: ${bestBand.name} (${bestBand.start}-${bestBand.end}Hz, SNR: ${bestBand.snr.toFixed(2)})`);

                return bestBand;
            }

            async transmitText(text) {
                // Convert text to hex for transmission
                const hexData = this.stringToHex(text);

                // Send data length first (16 bits as hex)
                const lengthHex = hexData.length.toString(16).padStart(4, '0');

                // Use parallel channels if enabled
                if (this.config.PARALLEL_CHANNELS === 2) {
                    await this.transmitParallel(lengthHex);
                    await this.transmitParallel(hexData);
                } else {
                    // Send length
                    for (let i = 0; i < lengthHex.length; i++) {
                        const hexChar = parseInt(lengthHex[i], 16);
                        await this.playTone(this.dataFrequencies[hexChar], this.config.TONE_DURATION);
                        await this.delay(this.config.INTER_SYMBOL_DELAY);
                    }

                    // Send data
                    for (let i = 0; i < hexData.length; i++) {
                        const hexChar = parseInt(hexData[i], 16);
                        await this.playTone(this.dataFrequencies[hexChar], this.config.TONE_DURATION);
                        await this.delay(this.config.INTER_SYMBOL_DELAY);
                    }
                }
            }

            async negotiateSpeed() {
                this.updateStatus('🔧 Testing connection speed...');

                const speeds = ['ultra-slow', 'slow', 'medium', 'fast', 'ultra-fast'];
                let bestSpeed = 'ultra-slow';

                for (let speed of speeds) {
                    this.currentSpeed = speed;
                    const profile = this.speedProfiles[speed];

                    this.updateStatus(`📡 Testing ${profile.name} speed...`);
                    console.log(`Testing speed: ${speed}`);

                    // CRITICAL: Pause listening while we transmit
                    this.pauseListening();

                    // Send test pattern
                    const testPattern = 'TEST_' + speed.toUpperCase();
                    await this.sendTestPatternOnly(testPattern, speed);

                    // CRITICAL: Resume listening and actually wait
                    this.resumeListening();

                    // Now wait for response with a proper promise
                    const success = await this.waitForSpeedResponse(speed, 3000);

                    if (success) {
                        bestSpeed = speed;
                        this.speedTestResults[speed] = true;
                        this.updateStatus(`✅ ${profile.name} speed works!`);
                        console.log(`Speed ${speed} acknowledged`);
                    } else {
                        // This speed failed, use previous one
                        this.updateStatus(`❌ ${profile.name} too fast, using ${this.speedProfiles[bestSpeed].name}`);
                        console.log(`Speed ${speed} failed or timed out`);
                        break;
                    }
                }

                this.negotiatedSpeed = bestSpeed;
                this.currentSpeed = bestSpeed;

                const finalProfile = this.speedProfiles[bestSpeed];
                this.config.TONE_DURATION = finalProfile.toneDuration;
                this.config.INTER_SYMBOL_DELAY = finalProfile.interToneDelay;

                this.updateStatus(`🎯 Using ${finalProfile.name} speed (${finalProfile.toneDuration}ms tones)`);

                return bestSpeed;
            }

            async transmitDataAtNegotiatedSpeed() {
                const profile = this.speedProfiles[this.negotiatedSpeed];

                // Prepare data
                const data = {
                    u: currentUsername.substring(0, 10),
                    a: {},
                    t: Date.now()
                };

                const answers = classData.users[currentUsername]?.answers || {};
                const recent = Object.keys(answers).slice(-5);

                recent.forEach(qId => {
                    const shortId = qId.substring(qId.lastIndexOf('-') + 1);
                    data.a[shortId] = answers[qId].value || answers[qId];
                });

                const json = JSON.stringify(data);
                const hexData = this.stringToHex(json);

                console.log(`Transmitting ${hexData.length} bytes at ${profile.name} speed`);

                // Send start pattern (always slow for reliability)
                await this.playTone(3000, 150);
                await this.delay(100);
                await this.playTone(3500, 150);
                await this.delay(100);
                await this.playTone(4000, 150);
                await this.delay(200);

                // Send length
                const lengthHex = hexData.length.toString(16).padStart(4, '0');
                for (let char of lengthHex) {
                    const freq = 3000 + (parseInt(char, 16) * 100);
                    await this.playTone(freq, profile.toneDuration);
                    await this.delay(profile.interToneDelay);
                }

                await this.delay(100);

                // Send data at negotiated speed
                for (let i = 0; i < hexData.length; i++) {
                    const hexChar = parseInt(hexData[i], 16);
                    const freq = 3000 + (hexChar * 100);
                    await this.playTone(freq, profile.toneDuration);
                    await this.delay(profile.interToneDelay);

                    if (i % 16 === 0) {
                        this.updateStatus(`📤 Sending: ${Math.round(i * 100 / hexData.length)}%`);
                    }

                    // Adaptive sync pauses based on speed
                    if (this.negotiatedSpeed === 'ultra-slow' && i % 8 === 7) {
                        await this.delay(200);
                    } else if (this.negotiatedSpeed === 'slow' && i % 16 === 15) {
                        await this.delay(100);
                    } else if (this.negotiatedSpeed === 'medium' && i % 32 === 31) {
                        await this.delay(50);
                    }
                }

                // Send end pattern
                await this.playTone(4000, 150);
                await this.delay(100);
                await this.playTone(3500, 150);
                await this.delay(100);
                await this.playTone(3000, 150);

                const totalTime = (hexData.length * (profile.toneDuration + profile.interToneDelay)) / 1000;
                this.updateStatus(`✅ Sent ${hexData.length} bytes in ~${totalTime.toFixed(1)}s`);

                setTimeout(() => this.complete(), 3000);
            }
        }

        // Initialize audio transfer with FastAudioProtocol optimizations
        const audioProtocol = new AudioProtocol();

        // Test configuration is loaded correctly
        console.log('FastAudioProtocol Config:', audioProtocol.config);
        console.log('Expected: ~50 symbols/sec = 200 bits/sec, 1KB in ~40 seconds');

        // Add to sync menu
        window.showAudioSync = function() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 2000; display: flex; align-items: center; justify-content: center;';
            modal.onclick = function(e) { if(e.target === modal) modal.remove(); };

            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 10px; max-width: 350px; width: 90%; text-align: center;">
                    <h2>🔊 Audio Transfer</h2>
                    <p>Choose your role:</p>

                    <button onclick="audioProtocol.startAsSender(); this.closest('[style*=fixed]').remove();"
                            class="sync-button" style="width: 100%; margin-bottom: 10px; background: #4CAF50;">
                        📤 Send Data
                        <div style="font-size: 12px; opacity: 0.8;">I will transmit my answers</div>
                    </button>

                    <button onclick="audioProtocol.startAsReceiver(); this.closest('[style*=fixed]').remove();"
                            class="sync-button" style="width: 100%; margin-bottom: 10px; background: #2196F3;">
                        📥 Receive Data
                        <div style="font-size: 12px; opacity: 0.8;">I will listen for answers</div>
                    </button>

                    <div style="padding: 10px; background: #fff3e0; border-radius: 5px; margin: 10px 0; font-size: 12px;">
                        ⚠️ Tips:<br>
                        • Keep devices 1-2 feet apart<br>
                        • Volume at 75% or higher<br>
                        • Quiet environment works best
                    </div>

                    <button onclick="this.closest('[style*=fixed]').remove()"
                            style="width: 100%; padding: 10px; background: none;
                                   border: 1px solid #ccc; border-radius: 4px;">
                        Cancel
                    </button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // QR Keyboard Sync System
        class QRKeyboardSync {
            constructor() {
                this.currentSession = null;
                this.curriculum = window.EMBEDDED_CURRICULUM?.questions || [];
                this.questionMap = this.buildQuestionMap();
            }

            // Build efficient question ID mapping
            buildQuestionMap() {
                const map = {};
                this.curriculum.forEach((q, index) => {
                    // Use last 3-4 chars of ID as short code
                    const shortId = q.id.replace(/^.*-/, '').substring(0, 4);
                    map[shortId] = index;
                });
                return map;
            }

            // Fixed student sync start
            startStudentSync() {
                const userAnswers = classData.users[currentUsername]?.answers || {};
                const answerCount = Object.keys(userAnswers).length;

                // Initial packet
                const handshake = {
                    type: 'INIT',
                    user: currentUsername,
                    count: answerCount,
                    timestamp: Date.now()
                };

                // Show QR first
                const modal = document.createElement('div');
                modal.id = 'student-sync-display';
                modal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 9999; padding: 20px;';
                modal.innerHTML = `
                    <div style="max-width: 500px; margin: 0 auto; text-align: center;">
                        <h2>Step 1: Show this QR to teacher</h2>
                        <div id="student-qr" style="margin: 20px auto;"></div>
                        <div style="padding: 20px; background: #f0f0f0; border-radius: 8px;">
                            <p>After teacher scans this, they will give you a code</p>
                            <input type="text"
                                   id="teacher-code"
                                   maxlength="6"
                                   style="font-size: 36px;
                                          letter-spacing: 8px;
                                          text-align: center;
                                          width: 300px;
                                          text-transform: uppercase;
                                          margin: 10px 0;"
                                   placeholder="------"
                                   onkeyup="this.value = this.value.toUpperCase()">
                            <br>
                            <button onclick="qrKeyboard.processSyncCode()"
                                    style="font-size: 20px; padding: 10px 30px; margin-top: 10px;">
                                I've Entered The Code
                            </button>
                        </div>
                        <button onclick="qrKeyboard.cancelStudentSync()"
                                style="margin-top: 20px; padding: 10px 20px; background: #f44336; color: white; border: none; border-radius: 4px;">
                            Cancel
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);

                // Generate QR
                new QRCode(document.getElementById('student-qr'), {
                    text: JSON.stringify(handshake),
                    width: 256,
                    height: 256
                });
            }

            // Add cancel methods
            cancelStudentSync() {
                document.getElementById('student-sync-display')?.remove();
                document.onkeydown = null;
            }

            cancelTeacherSync() {
                if (this.currentScanner) {
                    this.currentScanner.stop();
                }
                document.getElementById('teacher-receive')?.remove();
            }

            // Student: Wait for teacher to type sync code
            waitForSyncCode() {
                const modal = document.createElement('div');
                modal.id = 'sync-code-input';
                modal.innerHTML = `
                    <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                background: white; padding: 30px; border-radius: 10px; z-index: 9999;
                                box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                        <h2>Teacher will give you a code</h2>
                        <input type="text"
                               id="teacher-code"
                               maxlength="6"
                               style="font-size: 36px;
                                      letter-spacing: 8px;
                                      text-align: center;
                                      width: 300px;
                                      text-transform: uppercase;"
                               placeholder="------"
                               onkeyup="this.value = this.value.toUpperCase()">
                        <br><br>
                        <button onclick="qrKeyboard.processSyncCode()"
                                style="font-size: 20px; padding: 10px 30px;">
                            Process Code
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
                document.getElementById('teacher-code').focus();
            }

            // Student: Process teacher's sync code
            // Fix the student side to remove redundant CHUNKS QR:
            processSyncCode() {
                const code = document.getElementById('teacher-code').value;
                if (code.length < 5) {
                    alert('Code too short');
                    return;
                }

                // Close the initial modal
                document.getElementById('student-sync-display')?.remove();

                // Decode what teacher has
                const teacherState = this.decodeSyncCode(code);
                const myAnswers = classData.users[currentUsername]?.answers || {};

                // Calculate what needs to be sent
                const toSend = [];
                Object.keys(myAnswers).forEach(qId => {
                    const timestamp = classData.users[currentUsername].timestamps[qId];
                    if (!teacherState[qId] || teacherState[qId] < timestamp) {
                        toSend.push(qId);
                    }
                });

                // Prepare chunks
                this.prepareChunks(toSend);

                // SHOW THE CHUNKS QR - DON'T SKIP IT!
                if (this.chunks.length > 0) {
                    // Create chunks info packet
                    const chunksInfo = {
                        type: 'CHUNKS',
                        user: currentUsername,
                        count: this.chunks.length,
                        timestamp: Date.now()
                    };

                    // Show the chunks QR first
                    this.showStudentQR(chunksInfo, 'chunks');

                    // After teacher scans chunks QR, they'll press button
                    // Then we move to data QRs
                    this.currentChunk = 0;
                } else {
                    alert('No new data to send!');
                    this.cancelStudentSync();
                }
            }

            // New method to start showing data chunks:
            startShowingDataChunks() {
                this.currentChunk = 0;
                this.showStudentQR(null, 'data');
            }

            // Much more efficient chunk preparation
            prepareChunks(questionIds) {
                const CHUNK_SIZE = 3; // Only 3 questions per QR for reliability
                const chunks = [];

                for (let i = 0; i < questionIds.length; i += CHUNK_SIZE) {
                    const chunkIds = questionIds.slice(i, i + CHUNK_SIZE);
                    const chunkData = [];

                    chunkIds.forEach(qId => {
                        // Strip the question ID to minimum
                        const shortId = qId.split('-').pop(); // Just the last part
                        const answer = classData.users[currentUsername].answers[qId];

                        // Compress answer to single character if multiple choice
                        let shortAnswer = answer;
                        if (typeof answer === 'string' && answer.length === 1) {
                            shortAnswer = answer;
                        } else if (answer?.value) {
                            shortAnswer = answer.value;
                        }

                        // Create minimal data packet
                        chunkData.push({
                            q: shortId,  // Short question ID
                            a: shortAnswer, // Just the answer letter/number
                            t: Math.floor(Date.now()/1000) // Timestamp in seconds, not milliseconds
                        });
                    });

                    chunks.push(chunkData);
                }

                this.chunks = chunks;
                this.currentChunk = 0;

                console.log(`Prepared ${chunks.length} chunks, first chunk size: ${JSON.stringify(chunks[0]).length} chars`);
            }

            // Also optimize how we show the QR
            showStudentQR(data, stage) {
                let qrModal = document.getElementById('qr-display');

                if (!qrModal) {
                    qrModal = document.createElement('div');
                    qrModal.id = 'qr-display';
                    document.body.appendChild(qrModal);
                }

                let instruction = '';
                let qrData = data;

                if (stage === 'chunks') {
                    instruction = `Show this to teacher - tells them to expect ${data.count} QR codes`;
                    qrData = data;

                    // After showing chunks QR, wait for spacebar to move to data
                    document.onkeydown = (e) => {
                        if (e.code === 'Space') {
                            e.preventDefault();
                            this.currentChunk = 0;
                            this.showStudentQR(null, 'data');
                        }
                    };
                } else if (stage === 'data') {
                    if (this.chunks && this.currentChunk < this.chunks.length) {
                        instruction = `QR ${this.currentChunk + 1} of ${this.chunks.length}. Teacher scans, then press SPACE.`;

                        // Create minimal QR data WITH username
                        qrData = {
                            t: 'D', // Type = Data (single letter)
                            n: this.currentChunk, // Chunk number
                            d: this.chunks[this.currentChunk], // Data
                            u: currentUsername // ADD USERNAME HERE
                        };

                        // Show the data size for debugging
                        const dataSize = JSON.stringify(qrData).length;
                        console.log(`QR ${this.currentChunk + 1} size: ${dataSize} characters`);

                        if (dataSize > 200) {
                            console.warn('QR might be too dense! Size:', dataSize);
                        }
                    }
                }

                qrModal.style.cssText = 'position: fixed; inset: 0; background: white; z-index: 9999;';
                qrModal.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%;">
                        <div style="text-align: center;">
                            <h2>${instruction}</h2>
                            <div id="student-qr-display" style="margin: 20px auto;"></div>
                            <div style="font-size: 18px; color: #666;">
                                ${stage === 'data' ? `Data size: ${JSON.stringify(qrData).length} chars` : ''}
                            </div>
                            <div style="font-size: 24px; margin-top: 20px; padding: 20px; background: #f0f0f0; border-radius: 8px;">
                                ${stage === 'data' ? `
                                    <div>Progress: ${this.currentChunk + 1}/${this.chunks.length}</div>
                                    <div style="margin-top: 10px; color: #2196F3;">Press SPACEBAR for next QR</div>
                                ` : ''}
                            </div>
                            <button onclick="qrKeyboard.cancelStudentSync()"
                                    style="margin-top: 20px; padding: 10px 20px; background: #f44336; color: white; border: none; border-radius: 4px;">
                                Cancel
                            </button>
                        </div>
                    </div>
                `;

                // Generate QR with lower error correction for smaller size
                if (qrData) {
                    new QRCode(document.getElementById('student-qr-display'), {
                        text: JSON.stringify(qrData),
                        width: 300,
                        height: 300,
                        correctLevel: QRCode.CorrectLevel.L // Use Low error correction for smaller QR
                    });
                }

                if (stage === 'data') {
                    document.onkeydown = (e) => {
                        if (e.code === 'Space') {
                            e.preventDefault();
                            this.nextChunk();
                        }
                    };
                }
            }

            // Student: Move to next chunk
            nextChunk() {
                this.currentChunk++;

                if (this.currentChunk < this.chunks.length) {
                    // Show next chunk
                    this.showStudentQR(null, 'data');
                } else {
                    // All chunks sent, wait for final code
                    document.onkeydown = null; // Remove spacebar handler
                    this.waitForFinalCode();
                }
            }

            // Student: Wait for final state code
            waitForFinalCode() {
                document.getElementById('qr-display').innerHTML = `
                    <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                background: white; padding: 30px; border-radius: 10px;">
                        <h2>Enter Final Code from Teacher</h2>
                        <input type="text"
                               id="final-code"
                               maxlength="5"
                               style="font-size: 36px;
                                      letter-spacing: 8px;
                                      text-align: center;
                                      width: 250px;
                                      text-transform: uppercase;">
                        <br><br>
                        <button onclick="qrKeyboard.verifyFinalState()">Verify</button>
                    </div>
                `;
            }

            // Replace startTeacherReceive with this cleaner version:
            startTeacherReceive() {
                const modal = document.createElement('div');
                modal.id = 'teacher-receive';
                modal.innerHTML = `
                    <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                                background: white; z-index: 9999; overflow-y: auto;">

                        <!-- Camera view at top -->
                        <div style="background: #f5f5f5; padding: 10px;">
                            <div id="scanner-area" style="width: 100%; max-width: 300px; height: 300px; margin: 0 auto;"></div>
                        </div>

                        <!-- Status message -->
                        <div id="sync-status" style="padding: 15px; text-align: center; background: #e3f2fd; margin: 10px;">
                            📷 Ready to scan student's first QR
                        </div>

                        <!-- Code display - PROMINENT when shown -->
                        <div id="sync-code-display"
                             style="display: none;
                                    text-align: center;
                                    margin: 20px;
                                    padding: 30px;
                                    background: #ffeb3b;
                                    border: 3px solid #000;
                                    border-radius: 10px;
                                    font-size: 60px;
                                    letter-spacing: 15px;
                                    font-family: monospace;
                                    font-weight: bold;">
                        </div>

                        <!-- Cancel button at bottom -->
                        <div style="position: fixed; bottom: 20px; left: 20px; right: 20px;">
                            <button onclick="qrKeyboard.cancelTeacherSync()"
                                    style="width: 100%; padding: 15px; background: #f44336; color: white;
                                           border: none; border-radius: 8px; font-size: 18px;">
                                Cancel
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                this.startScanner();
            }

            // Teacher: Initialize camera scanner
            // Update startScanner to support pause/resume:
            startScanner() {
                const html5QrCode = new Html5Qrcode("scanner-area");

                html5QrCode.start(
                    { facingMode: "environment" },
                    {
                        fps: 10,
                        qrbox: { width: 250, height: 250 }
                    },
                    (decodedText) => {
                        this.processScannedQR(decodedText);
                    }
                ).catch(err => {
                    html5QrCode.start(
                        { facingMode: "user" },
                        {
                            fps: 10,
                            qrbox: { width: 250, height: 250 }
                        },
                        (decodedText) => {
                            this.processScannedQR(decodedText);
                        }
                    ).catch(err => {
                        document.getElementById('sync-status').textContent =
                            'Camera error. Please check permissions.';
                    });
                });

                this.currentScanner = html5QrCode;
                this.scannedChunks = new Set(); // Track scanned chunk numbers
            }

            // Teacher: Generate sync code for student
            generateSyncCode(username) {
                const userInPhone = classData.users[username] || {};
                const answers = userInPhone.answers || {};

                // Create a 5-character code representing what we have
                // Format: 2 chars for count, 3 chars for checksum
                const count = Object.keys(answers).length;
                const countCode = count.toString(36).padStart(2, '0').toUpperCase();

                // Simple checksum of question IDs
                let checksum = 0;
                Object.keys(answers).forEach(qId => {
                    const shortId = qId.replace(/^.*-/, '');
                    checksum += shortId.charCodeAt(0);
                });
                const checksumCode = (checksum % 46656).toString(36).padStart(3, '0').toUpperCase();

                return countCode + checksumCode;
            }

            // Decode sync code
            decodeSyncCode(code) {
                const count = parseInt(code.substring(0, 2), 36);
                // Return simplified state
                return { expectedCount: count };
            }

            // Replace processScannedQR with this version that prevents duplicates:
            processScannedQR(data) {
                try {
                    const parsed = JSON.parse(data);

                    // INIT: First QR from student
                    if (parsed.type === 'INIT') {
                        this.currentStudent = parsed.user;
                        this.receivedChunks = 0;
                        this.expectedChunks = 0;
                        this.lastScannedData = null;
                        this.scannedChunks = new Set();

                        const syncCode = this.generateSyncCode(parsed.user);

                        // Pause scanner
                        if (this.currentScanner) {
                            this.currentScanner.pause();
                        }

                        // Show code prominently
                        document.getElementById('sync-code-display').style.display = 'block';
                        document.getElementById('sync-code-display').textContent = syncCode;

                        // Add button to continue after student enters code
                        document.getElementById('sync-status').innerHTML = `
                            <div style="padding: 15px; background: #fff3e0; border-radius: 8px;">
                                <div><strong>Student: ${parsed.user}</strong></div>
                                <div style="margin: 10px 0;">Tell them code: <strong style="color: #ff9800;">${syncCode}</strong></div>
                                <button onclick="qrKeyboard.startReceivingData()"
                                        style="margin-top: 15px;
                                               padding: 15px 30px;
                                               background: #4CAF50;
                                               color: white;
                                               border: none;
                                               border-radius: 8px;
                                               font-size: 18px;">
                                    Student Entered Code - Continue
                                </button>
                            </div>
                        `;

                        return;
                    }

                    // CHUNKS: Student informing how many data QRs to expect
                    if (parsed.type === 'CHUNKS') {
                        this.expectedChunks = parsed.count;
                        this.receivedChunks = 0;

                        document.getElementById('sync-status').innerHTML = `
                            <div style="padding: 20px; background: #fff3e0; border-radius: 8px;">
                                <div>Expecting ${parsed.count} data QRs from ${parsed.user}</div>
                                <button onclick="qrKeyboard.startReceivingData()"
                                        style="margin-top: 15px; padding: 15px 30px;
                                               background: #4CAF50; color: white;
                                               border: none; border-radius: 8px;">
                                    Ready to Receive Data
                                </button>
                            </div>
                        `;

                        return;
                    }

                    // DATA: Actual answer data
                    if (parsed.t === 'D') {
                        // PREVENT DUPLICATE SCANS
                        const dataString = JSON.stringify(parsed);
                        if (this.lastScannedData === dataString) {
                            return; // Same QR, ignore it
                        }
                        this.lastScannedData = dataString;

                        // Also check chunk number to prevent re-scanning
                        if (parsed.n !== undefined && this.scannedChunks && this.scannedChunks.has(parsed.n)) {
                            return; // Already scanned this chunk number
                        }

                        // Track which chunks we've scanned
                        if (!this.scannedChunks) {
                            this.scannedChunks = new Set();
                        }
                        if (parsed.n !== undefined) {
                            this.scannedChunks.add(parsed.n);
                        }

                        this.receivedChunks = (this.receivedChunks || 0) + 1;

                        // IMMEDIATELY PAUSE SCANNER after successful scan
                        if (this.currentScanner) {
                            this.currentScanner.pause();
                        }

                        // Process the data
                        if (parsed.u) {
                            this.currentStudent = parsed.u;
                        }
                        if (!this.currentStudent) {
                            this.currentStudent = 'unknown_student';
                        }

                        // Save answers
                        if (!classData.users[this.currentStudent]) {
                            classData.users[this.currentStudent] = {
                                answers: {},
                                reasons: {},
                                timestamps: {},
                                attempts: {}
                            };
                        }

                        if (parsed.d && Array.isArray(parsed.d)) {
                            parsed.d.forEach(item => {
                                const qId = `q-${item.q}`;
                                classData.users[this.currentStudent].answers[qId] = item.a;
                                classData.users[this.currentStudent].timestamps[qId] = (item.t || Date.now()/1000) * 1000;
                            });
                            saveClassData();
                        }

                        // Check if done
                        if (this.receivedChunks >= this.expectedChunks) {
                            // Generate final code
                            const finalCode = this.generateFinalCode();

                            document.getElementById('sync-code-display').style.display = 'block';
                            document.getElementById('sync-code-display').textContent = finalCode;
                            document.getElementById('sync-code-display').style.background = '#4CAF50';
                            document.getElementById('sync-code-display').style.color = 'white';

                            document.getElementById('sync-status').innerHTML = `
                                <div style="padding: 20px; background: #c8e6c9; border-radius: 8px;">
                                    <div style="font-size: 24px;">✅ All Done!</div>
                                    <div>Received ${this.receivedChunks} QRs</div>
                                    <div style="margin-top: 10px;">Give student code above ☝️</div>
                                </div>
                            `;
                        } else {
                            // Show status with READY button
                            document.getElementById('sync-status').innerHTML = `
                                <div style="padding: 20px; background: #c8e6c9; border-radius: 8px;">
                                    <div style="font-size: 36px; color: #4CAF50;">
                                        ✅ Got QR #${this.receivedChunks}
                                    </div>
                                    <div style="margin: 15px 0;">
                                        Tell student: <strong>"Press SPACEBAR"</strong>
                                    </div>
                                    <button onclick="qrKeyboard.readyForNext()"
                                            style="padding: 15px 30px;
                                                   background: #2196F3;
                                                   color: white;
                                                   border: none;
                                                   border-radius: 8px;
                                                   font-size: 20px;">
                                        Ready for QR #${this.receivedChunks + 1}
                                    </button>
                                </div>
                            `;
                        }

                        return;
                    }

                } catch(error) {
                    console.error('QR scan error:', error);
                }
            }

            // Add method to resume scanning
            readyForNext() {
                // Clear last scan data to allow new scan
                this.lastScannedData = null;

                // Resume scanner
                if (this.currentScanner) {
                    this.currentScanner.resume();
                }

                // Update display
                document.getElementById('sync-status').innerHTML = `
                    <div style="padding: 20px; background: #e3f2fd; border-radius: 8px;">
                        <div style="font-size: 24px;">📷 Scanning...</div>
                        <div>Point at QR #${(this.receivedChunks || 0) + 1}</div>
                    </div>
                `;
            }

            // Add method to start receiving data QRs:
            startReceivingData() {
                // Hide the sync code
                document.getElementById('sync-code-display').style.display = 'none';

                // Clear last scan data
                this.lastScannedData = null;

                // Resume scanner
                if (this.currentScanner) {
                    this.currentScanner.resume();
                }

                // Update display
                document.getElementById('sync-status').innerHTML = `
                    <div style="padding: 20px; background: #e3f2fd; border-radius: 8px;">
                        <div style="font-size: 24px;">📷 Ready to scan data QRs</div>
                        <div>Point camera at student's screen</div>
                    </div>
                `;
            }

            // Make sure generateFinalCode exists and is simple:
            generateFinalCode() {
                // Generate a 5-character code starting with DONE
                const num = Math.floor(Math.random() * 10);
                return 'DONE' + num;  // Returns "DONE0" through "DONE9"
            }

            // Add manual complete method
            manualComplete() {
                const finalCode = this.generateFinalCode();

                document.getElementById('sync-code-display').style.display = 'block';
                document.getElementById('sync-code-display').textContent = finalCode;
                document.getElementById('sync-code-display').style.background = '#4CAF50';
                document.getElementById('sync-code-display').style.color = 'white';

                document.getElementById('sync-status').innerHTML = `
                    <div style="padding: 20px; background: #c8e6c9; border-radius: 8px;">
                        <div style="font-size: 24px;">✅ Manual Complete</div>
                        <div>${this.receivedChunks} QRs received</div>
                        <div style="margin-top: 10px;">Give student code above ☝️</div>
                    </div>
                `;
            }

            // Also fix the student's final code verification:
            verifyFinalState() {
                const code = document.getElementById('final-code').value.toUpperCase();

                if (code.startsWith('DONE')) {
                    // Success! Send confirmation
                    const confirmation = {
                        type: 'CONFIRM',
                        user: currentUsername,
                        timestamp: Date.now()
                    };

                    document.getElementById('qr-display').innerHTML = `
                        <div style="position: fixed; inset: 0; background: white; z-index: 9999;
                                    display: flex; align-items: center; justify-content: center;">
                            <div style="text-align: center;">
                                <h2>✅ Sync Complete!</h2>
                                <p>Show this final QR to teacher:</p>
                                <div id="final-qr" style="margin: 20px auto;"></div>
                                <button onclick="qrKeyboard.finishSync()"
                                        style="margin-top: 20px; padding: 10px 30px; background: #4CAF50;
                                               color: white; border: none; border-radius: 4px; font-size: 18px;">
                                    Done
                                </button>
                            </div>
                        </div>
                    `;

                    new QRCode(document.getElementById('final-qr'), {
                        text: JSON.stringify(confirmation),
                        width: 200,
                        height: 200
                    });
                } else {
                    alert('Invalid code. Please check with teacher.');
                }
            }

            // Add finish sync method
            finishSync() {
                document.getElementById('qr-display')?.remove();
                document.onkeydown = null;
                loadProgress(); // Refresh the UI to show any new data
            }

            // Add to QRKeyboardSync class
            mergeChunkData(chunkData) {
                // Initialize user if doesn't exist
                if (!classData.users[this.currentStudent]) {
                    classData.users[this.currentStudent] = {
                        answers: {},
                        reasons: {},
                        timestamps: {},
                        attempts: {}
                    };
                }

                // Merge the chunk
                Object.keys(chunkData).forEach(qId => {
                    const data = chunkData[qId];
                    classData.users[this.currentStudent].answers[qId] = data.a;
                    classData.users[this.currentStudent].reasons[qId] = data.r || '';
                    classData.users[this.currentStudent].timestamps[qId] = data.t || Date.now();
                });

                // Save to localStorage
                saveClassData();
            }

            findFullQuestionId(shortId) {
                // First try exact match at the end
                for (let q of this.curriculum) {
                    if (q.id.endsWith(shortId) || q.id.endsWith(`-${shortId}`)) {
                        return q.id;
                    }
                }

                // Then try contains
                for (let q of this.curriculum) {
                    if (q.id.includes(shortId)) {
                        return q.id;
                    }
                }

                console.warn(`Could not find question with short ID: ${shortId}`);

                // Last resort - construct a probable ID
                // Most IDs follow pattern like U1-L1-1, U2-L3-12, etc.
                if (/^\d+$/.test(shortId)) {
                    // It's just a number, try to construct based on current context
                    // This is a fallback - ideally we'd have better context
                    return `question-${shortId}`;
                }

                return null;
            }

            resetForNext() {
                // Reset for next student
                this.currentStudent = null;
                this.expectedChunks = 0;
                this.receivedChunks = 0;
                this.chunks = [];

                document.getElementById('sync-code-display').style.display = 'none';
                document.getElementById('sync-status').textContent = 'Ready for next student';
            }
        }

        // Initialize
        const qrKeyboard = new QRKeyboardSync();

        // Add buttons to UI
        window.startStudentQRKeyboard = () => qrKeyboard.startStudentSync();
        window.startTeacherQRKeyboard = () => qrKeyboard.startTeacherReceive();

        // Add a button to manually finish and generate final code:
        window.finishStudentSync = function() {
            const finalCode = 'DONE' + Math.floor(Math.random() * 10);

            document.getElementById('sync-code-display').style.display = 'block';
            document.getElementById('sync-code-display').textContent = finalCode;
            document.getElementById('sync-code-display').style.background = '#4CAF50';
            document.getElementById('sync-code-display').style.color = 'white';

            document.getElementById('sync-status').innerHTML = `
                <button onclick="finishStudentSync()"
                        style="padding: 10px 20px; background: #2196F3; color: white;
                               border: none; border-radius: 5px; font-size: 16px;">
                    Generate Final Code
                </button>
                <div style="margin-top: 10px;">
                    Give student the code above to finish
                </div>
            `;
        }
    </script>
</body>
</html>
